<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://github.com/iriscouch/follow"

    >follow (v0.12.1)</a>
</h1>
<h4>Extremely robust, fault-tolerant CouchDB changes follower</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow">module follow</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.follow">
            function <span class="apidocSignatureSpan"></span>follow
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes">
            function <span class="apidocSignatureSpan">follow.</span>Changes
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed">
            function <span class="apidocSignatureSpan">follow.</span>Feed
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>Changes.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>Feed.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>cli</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>eventemitter2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>feed</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>index</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>stream</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes">module follow.Changes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.Changes">
            function <span class="apidocSignatureSpan">follow.</span>Changes
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.super_">
            function <span class="apidocSignatureSpan">follow.Changes.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype">module follow.Changes.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.destroy">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.destroySoon">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroySoon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.emit_changes">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>emit_changes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.end">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>end
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.error">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>error
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.normalize_data">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>normalize_data
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.pause">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.resume">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.setEncoding">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setEncoding
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.setHeader">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setHeader
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.write">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.write_continuous">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_continuous
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.write_longpoll">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_longpoll
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed">module follow.Feed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.Feed">
            function <span class="apidocSignatureSpan">follow.</span>Feed
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.super_">
            function <span class="apidocSignatureSpan">follow.Feed.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype">module follow.Feed.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.check_for_catchup">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>check_for_catchup
            <span class="apidocSignatureSpan">(seq)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.confirm">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>confirm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.die">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>die
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.follow">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>follow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.got_activity">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>got_activity
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_change">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_change
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_data">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_data
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_end">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_error">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_error
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_heartbeat">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_heartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_good_change">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_good_change
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_inactivity">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_inactivity
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_timeout">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_timeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.pause">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.prep">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>prep
            <span class="apidocSignatureSpan">(changes_stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.query">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>query
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.restart">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>restart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.resume">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.retry">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>retry
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.start">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.stop">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>stop
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.wait">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>wait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.cli">module follow.cli</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.cli.main">
            function <span class="apidocSignatureSpan">follow.cli.</span>main
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.eventemitter2">module follow.eventemitter2</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.eventemitter2.EventEmitter2">
            function <span class="apidocSignatureSpan">follow.eventemitter2.</span>EventEmitter2
            <span class="apidocSignatureSpan">(conf)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.feed">module follow.feed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.feed.Feed">
            function <span class="apidocSignatureSpan">follow.feed.</span>Feed
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.index">module follow.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.index.JDUP">
            function <span class="apidocSignatureSpan">follow.index.</span>JDUP
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.index.JP">
            function <span class="apidocSignatureSpan">follow.index.</span>JP
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.index.JS">
            function <span class="apidocSignatureSpan">follow.index.</span>JS
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.index.clearTimeout">
            function <span class="apidocSignatureSpan">follow.index.</span>clearTimeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.index.scrub_creds">
            function <span class="apidocSignatureSpan">follow.index.</span>scrub_creds
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.index.setTimeout">
            function <span class="apidocSignatureSpan">follow.index.</span>setTimeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.index.timeouts">
            function <span class="apidocSignatureSpan">follow.index.</span>timeouts
            <span class="apidocSignatureSpan">(set, clear)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.index.</span>log4js</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.stream">module follow.stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.stream.Changes">
            function <span class="apidocSignatureSpan">follow.stream.</span>Changes
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow" id="apidoc.module.follow">module follow</a></h1>


    <h2>
        <a href="#apidoc.element.follow.follow" id="apidoc.element.follow.follow">
        function <span class="apidocSignatureSpan"></span>follow
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function follow_feed(opts, cb) {
  var ch_feed = new feed.Feed(opts);
  ch_feed.on(&#x27;error&#x27; , function(er) { return cb &#x26;&#x26; cb.call(ch_feed, er) });
  ch_feed.on(&#x27;change&#x27;, function(ch) { return cb &#x26;&#x26; cb.call(ch_feed, null, ch) });

  // Give the caller a chance to hook into any events.
  process.nextTick(function() {
    ch_feed.follow();
  })

  return ch_feed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

process.on(&#x27;uncaughtException&#x27;, function(er) {
  puts(&#x27;========= UNCAUGHT EXCEPTION; This is bad&#x27;);
  puts(er.stack);
  setTimeout(function() { process.exit(1) }, 100);
})

feed.<span class="apidocCodeKeywordSpan">follow</span>();
}

exports.main = main;
if(!require.isBrowser &#x26;&#x26; process.argv[1] == module.filename)
main();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes" id="apidoc.element.follow.Changes">
        function <span class="apidocSignatureSpan">follow.</span>Changes
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Changes(opts) {
  var self = this
  stream.call(self)

  self.readable = true
  self.writable = true

  self.headers = {}
  self.statusCode = null

  opts = opts || {}
  self.feed = opts.feed || null // &#x22;continuous&#x22; or &#x22;longpoll&#x22;
  self.encoding = opts.encoding || &#x27;utf8&#x27;

  self.log = opts.log
  if(!self.log) {
    self.log = lib.log4js.getLogger(&#x27;change_stream&#x27;)
    self.log.setLevel(DEFS.log_level)
  }

  self.is_sending = true
  self.is_ending = false
  self.is_dead = false

  self.source = null
  self.expect = null
  self.buf = null
  self.changes = []

  self.on(&#x27;pipe&#x27;, function(src) {
    if(!self.source)
      self.source = src
    else {
      var er = new Error(&#x27;Already have a pipe source&#x27;)
      er.source = self.source
      self.error(er)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed" id="apidoc.element.follow.Feed">
        function <span class="apidocSignatureSpan">follow.</span>Feed
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Feed(opts) {
  var self = this;
  EventEmitter.call(self);

  opts = opts || {}

  self.feed = &#x27;continuous&#x27;;
  self.heartbeat         = opts.heartbeat || DEFAULT_HEARTBEAT;
  self.max_retry_seconds = opts.max_retry_seconds || DEFAULT_MAX_RETRY_SECONDS;
  self.inactivity_ms = null;
  self.initial_retry_delay = opts.initial_retry_delay || INITIAL_RETRY_DELAY;
  self.response_grace_time = opts.response_grace_time || RESPONSE_GRACE_TIME;

  self.headers = {};
  self.request = opts.request || {} // Extra options for potentially future versions of request. The caller can supply them.

  self.since = 0;
  self.is_paused = false
  self.caught_up = false
  self.retry_delay = self.initial_retry_delay;

  self.query_params = {}; // Extra `req.query` values for filter functions

  if(typeof opts === &#x27;string&#x27;)
    opts = {&#x27;db&#x27;: opts};

  Object.keys(opts).forEach(function(key) {
    if (typeof self[key] !== &#x27;function&#x27;)
      self[key] = opts[key];
  })

  self.pending = { request     : null
                 , activity_at : null
                 };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
process.stdout.write(str + &#x22;\n&#x22;);
}

function main() {
var db = require.isBrowser ? (process.env.db || &#x27;/_users&#x27;) : process.argv[2];
puts(&#x27;Watching: &#x27; + db);

var feed = new couch_changes.<span class="apidocCodeKeywordSpan">Feed</span>();
feed.db = db;
feed.since = (process.env.since === &#x27;now&#x27;) ? &#x27;now&#x27; : parseInt(process.env.since || &#x27;0&#x27;);

feed.heartbeat = (process.env.heartbeat || &#x27;3000&#x27;).replace(/s$/, &#x27;000&#x27;);
feed.heartbeat = parseInt(feed.heartbeat);

if(require.isBrowser)
...</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes" id="apidoc.module.follow.Changes">module follow.Changes</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.Changes" id="apidoc.element.follow.Changes.Changes">
        function <span class="apidocSignatureSpan">follow.</span>Changes
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Changes(opts) {
  var self = this
  stream.call(self)

  self.readable = true
  self.writable = true

  self.headers = {}
  self.statusCode = null

  opts = opts || {}
  self.feed = opts.feed || null // &#x22;continuous&#x22; or &#x22;longpoll&#x22;
  self.encoding = opts.encoding || &#x27;utf8&#x27;

  self.log = opts.log
  if(!self.log) {
    self.log = lib.log4js.getLogger(&#x27;change_stream&#x27;)
    self.log.setLevel(DEFS.log_level)
  }

  self.is_sending = true
  self.is_ending = false
  self.is_dead = false

  self.source = null
  self.expect = null
  self.buf = null
  self.changes = []

  self.on(&#x27;pipe&#x27;, function(src) {
    if(!self.source)
      self.source = src
    else {
      var er = new Error(&#x27;Already have a pipe source&#x27;)
      er.source = self.source
      self.error(er)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.super_" id="apidoc.element.follow.Changes.super_">
        function <span class="apidocSignatureSpan">follow.Changes.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype" id="apidoc.module.follow.Changes.prototype">module follow.Changes.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.destroy" id="apidoc.element.follow.Changes.prototype.destroy">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  var self = this
  self.log.debug(&#x27;destroy&#x27;)

  self.is_dead = true
  self.is_ending = false
  self.is_sending = false

  if(self.source &#x26;&#x26; typeof self.source.abort == &#x27;function&#x27;)
    return self.source.abort()

  if(self.source &#x26;&#x26; typeof self.source.destroy === &#x27;function&#x27;)
    self.source.destroy()

  // Often the source is from the request package, so destroy its response object.
  if(self.source &#x26;&#x26; self.source.__isRequestRequest &#x26;&#x26; self.source.response
  &#x26;&#x26; typeof self.source.response.destroy === &#x27;function&#x27;)
    self.source.response.destroy()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

function destroy_req(req) {
if(req)
  destroy_response(req.response)

if(req &#x26;&#x26; typeof req.destroy == &#x27;function&#x27;)
  req.<span class="apidocCodeKeywordSpan">destroy</span>()
}

function destroy_response(response) {
if(!response)
  return;

if(typeof response.abort === &#x27;function&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.destroySoon" id="apidoc.element.follow.Changes.prototype.destroySoon">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroySoon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroySoon = function () {
  var self = this
  throw new Error(&#x27;not implemented&#x27;)
  //return self.request.destroySoon()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self.source.response.destroy()
}


Changes.prototype.destroySoon = function() {
  var self = this
  throw new Error(&#x27;not implemented&#x27;)
  //return self.request.<span class="apidocCodeKeywordSpan">destroySoon</span>()
}

//
// Internal implementation
//

Changes.prototype.normalize_data = function(data, encoding) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.emit_changes" id="apidoc.element.follow.Changes.prototype.emit_changes">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>emit_changes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit_changes = function () {
  var self = this

  while(self.is_sending &#x26;&#x26; self.changes.length &#x3e; 0) {
    var change = self.changes.shift()
    if(change === &#x22;&#x22;) {
      self.log.debug(&#x27;emit: heartbeat&#x27;)
      self.emit(&#x27;heartbeat&#x27;)
    }

    else {
      self.log.debug(&#x27;emit: data&#x27;)
      self.emit(&#x27;data&#x27;, change)
    }
  }

  if(self.is_sending &#x26;&#x26; self.is_ending &#x26;&#x26; self.changes.length === 0) {
    self.is_ending = false
    self.readable = false
    self.log.debug(&#x27;emit: end&#x27;)
    self.emit(&#x27;end&#x27;)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


Changes.prototype.resume = function() {
  var self = this
  self.is_sending = true
  if(self.source &#x26;&#x26; self.source.resume)
    self.source.resume()
  self.<span class="apidocCodeKeywordSpan">emit_changes</span>()
}

//
// Writable stream API
//

Changes.prototype.write = function(data, encoding) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.end" id="apidoc.element.follow.Changes.prototype.end">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>end
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (data, encoding) {
  var self = this

  self.is_ending = true
  self.writable = false

  // Always call write, even with no data, so it can fire the &#x22;end&#x22; event.
  self.write(data, encoding)

  if(self.feed === &#x27;longpoll&#x27;) {
    var changes = [ DEFS.longpoll_header ].concat(self.buf).join(&#x27;&#x27;)
    try { changes = JSON.parse(changes) || {} }
    catch (er) { return self.error(er) }

    if(!Array.isArray(changes.results))
      return self.error(new Error(&#x27;No &#x22;results&#x22; field in feed&#x27;))
    if(self.changes.length !== 0)
      return self.error(new Error(&#x27;Changes are already queued: &#x27; + JSON.stringify(self.changes)))

    self.changes = changes.results.map(function(change) { return JSON.stringify(change) })
    return self.emit_changes()
  }

  else if(self.feed === &#x27;continuous&#x27;) {
    if(self.buf !== &#x22;&#x22;)
      self.log.debug(&#x27;Unprocessed data after &#x22;end&#x22; called: &#x27; + util.inspect(self.buf))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.error" id="apidoc.element.follow.Changes.prototype.error">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>error
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (er) {
  var self = this

  self.readable = false
  self.writable = false
  self.emit(&#x27;error&#x27;, er)

  // The write() method sometimes returns this value, so if there was an error, make write() return false.
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})

feed.on(&#x27;response&#x27;, function() {
  puts(&#x27;Streaming response:&#x27;);
})

feed.on(&#x27;error&#x27;, function(er) {
  //console.<span class="apidocCodeKeywordSpan">error</span>(er);
  console.error(&#x27;Changes error ============\n&#x27; + er.stack);
  setTimeout(function() { process.exit(0) }, 100);
})

process.on(&#x27;uncaughtException&#x27;, function(er) {
  puts(&#x27;========= UNCAUGHT EXCEPTION; This is bad&#x27;);
  puts(er.stack);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.normalize_data" id="apidoc.element.follow.Changes.prototype.normalize_data">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>normalize_data
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalize_data = function (data, encoding) {
  var self = this

  if(data instanceof Buffer)
    data = data.toString(encoding)
  else if(typeof data === &#x27;undefined&#x27; &#x26;&#x26; typeof encoding === &#x27;undefined&#x27;)
    data = &#x22;&#x22;

  if(typeof data != &#x27;string&#x27;)
    return self.error(new Error(&#x27;Not a string or Buffer: &#x27; + util.inspect(data)))

  if(self.feed !== &#x27;continuous&#x27; &#x26;&#x26; self.feed !== &#x27;longpoll&#x27;)
    return self.error(new Error(&#x27;Must set .feed to &#x22;continuous&#x22; or &#x22;longpoll&#x22; before writing data&#x27;))

  if(self.expect === null)
    self.expect = (self.feed == &#x27;longpoll&#x27;)
                    ? DEFS.longpoll_header
                    : &#x22;&#x22;

  var prefix = data.substr(0, self.expect.length)
  data = data.substr(prefix.length)

  var expected_part = self.expect.substr(0, prefix.length)
    , expected_remainder = self.expect.substr(expected_part.length)

  if(prefix !== expected_part)
    return self.error(new Error(&#x27;Prefix not expected &#x27;+util.inspect(expected_part)+&#x27;: &#x27; + util.inspect(prefix)))

  self.expect = expected_remainder
  return data
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// Writable stream API
//

Changes.prototype.write = function(data, encoding) {
var self = this

data = self.<span class="apidocCodeKeywordSpan">normalize_data</span>(data, encoding)
if(typeof data != &#x27;string&#x27;)
  return // Looks like normalize_data emitted an error.

if(self.feed === &#x27;longpoll&#x27;)
  return self.write_longpoll(data)
else if(self.feed === &#x27;continuous&#x27;)
  return self.write_continuous(data)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.pause" id="apidoc.element.follow.Changes.prototype.pause">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  var self = this
  self.is_sending = false

  if(self.source &#x26;&#x26; self.source.pause)
    self.source.pause()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var now = new Date;
self.pending.request = changes_stream;
self.pending.activity_at = now;
self.pending.wait_timer  = null;

// Just re-run the pause or resume to do the needful on changes_stream (self.pending.request).
if(self.is_paused)
  self.<span class="apidocCodeKeywordSpan">pause</span>()
else
  self.resume()

// The inactivity timer is for time between *changes*, or time between the
// initial connection and the first change. Therefore it goes here.
self.change_at = now;
if(self.inactivity_ms) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.resume" id="apidoc.element.follow.Changes.prototype.resume">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  var self = this
  self.is_sending = true
  if(self.source &#x26;&#x26; self.source.resume)
    self.source.resume()
  self.emit_changes()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
d.configure(i);return d.require(a,c)};d.config=function(a){return d(a)};typeof require===&#x22;undefined&#x22;&#x26;&#x26;(require
=d);d.toUrl=function(a){return z._.toUrl(a)};d.version=&#x22;0.26.0&#x22;;d.isArray=E;d.isFunction=M;d.mixin=V;d.jsExtRegExp=/^\/|:|\?|\.js$/;i=d.s={contexts:z,skipAsync:{},isPageLoaded:!B,readyCalls:[]};if(d.isAsync=d.isBrowser=B)if(u=i.head=document.getElementsByTagName(&#x22;head&#x22;)[0],L=document.getElementsByTagName(&#x22;base&#x22;)[0])u=i.head=L.parentNode;d.onError=function(a){throw a;};d.load=function(a,c,
g){var e=a.loaded;e[c]||(e[c]=!1);a.scriptCount+=1;d.attach(g,a,c);if(a.jQuery&#x26;&#x26;!a.jQueryIncremented)W(a.jQuery,!0),a.
jQueryIncremented=!0};define=d.def=function(a,c,g){var e,i;typeof a!==&#x22;string&#x22;&#x26;&#x26;(g=c,c=a,a=null);d.isArray(c
)||(g=c,c=[]);!a&#x26;&#x26;!c.length&#x26;&#x26;d.isFunction(g)&#x26;&#x26;g.length&#x26;&#x26;(g.toString().replace(ma,&#x22;&#
x22;).replace(na,function(a,d){c.push(d)}),c=(g.length===1?[&#x22;require&#x22;]:[&#x22;require&#x22;,&#x22;exports&#x22;,&#x22;
module&#x22;]).concat(c));if(N&#x26;&#x26;(e=I||la()))a||(a=e.getAttribute(&#x22;data-requiremodule&#x22;)),i=z[e.getAttribute(&#
x22;data-requirecontext&#x22;)];
(i?i.defQueue:U).push([a,c,g])};define.amd={multiversion:!0,plugins:!0,jQuery:!0};d.exec=function(a){return eval(a)};d.execCb=function
(a,c,d,e){return c.apply(e,d)};d.onScriptLoad=function(a){var c=a.currentTarget||a.srcElement,g;if(a.type===&#x22;load&#x22;||oa
.test(c.readyState))C=null,a=c.getAttribute(&#x22;data-requirecontext&#x22;),g=c.getAttribute(&#x22;data-requiremodule&#x22;),z[
a].completeLoad(g),c.detachEvent&#x26;&#x26;!da?c.detachEvent(&#x22;onreadystatechange&#x22;,d.onScriptLoad):c.removeEventListener
(&#x22;load&#x22;,d.onScriptLoad,!1)};d.attach=
function(a,c,g,e,q){var j;if(B)return e=e||d.onScriptLoad,j=c&#x26;&#x26;c.config&#x26;&#x26;c.config.xhtml?document.createElementNS
(&#x22;http://www.w3.org/1999/xhtml&#x22;,&#x22;html:script&#x22;):document.createElement(&#x22;script&#x22;),j.type=q||&#x22;text
/javascript&#x22;,j.charset=&#x22;utf-8&#x22;,j.async=!i.skipAsync[a],c&#x26;&#x26;j.setAttribute(&#x22;data-requirecontext&#x22
;,c.contextName),j.setAttribute(&#x22;data-requiremodule&#x22;,g),j.attachEvent&#x26;&#x26;!da?(N=!0,j.attachEvent(&#x22;onreadystatechange
&#x22;,e)):j.addEventListener(&#x22;load&#x22;,e,!1),j.src=a,I=j,L?u.insertBefore(j,L):u.appendChild(j),
I=null,j;else if(ca)e=c.loaded,e[g]=!1,importScripts(a),c.completeLoad(g);return null};if(B){v=document.getElementsByTagName(&#x22
;script&#x22;);for(H=v.length-1;H&#x3e;-1&#x26;&#x26;(A=v[H]);H--){if(!u)u=A.parentNode;if(D=A.getAttribute(&#x22;data-main&#x22
;)){if(!q.baseUrl)v=D.split(&#x22;/&#x22;),A=v.pop(),v=v.length?v.join(&#x22;/&#x22;)+&#x22;/&#x22;:&#x22;./&#x22;,q.baseUrl=v,D
=A.replace(ba,&#x22;&#x22;);q.deps=q.deps?q.deps.concat(D):[D];break}}}i.baseUrl=q.baseUrl;d.pageLoaded=function(){if(!i.isPageLoaded
){i.isPageLoaded=!0;Q&#x26;&#x26;clearInterval(Q);if(ea)document.readyState=&#x22;complete&#x22;;
d.callReady()}};d.checkReadyState=function(){var a=i.contexts,c;for(c in a)if(!(c in J)&#x26;&#x26;a[c].waitCount)return;i.isDone
=!0;d.callReady()};d.callReady=function(){var a=i.readyCalls,c,d,e;if(i.isPageLoaded&#x26;&#x26;i.isDone){if(a.length){i.readyCalls
=[];for(c=0;d=a[c];c++)d()}a=i.contexts;for(e in a)if(!(e in J)&#x26;&#x26;(c=a[e],c.jQueryIncremented))W(c.jQuery,!1),c.jQueryIncremented
=!1}};d.ready=function(a){i.isPageLoaded&#x26;&#x26;i.isDone?a():i.readyCalls.push(a);return d};if(B){if(document.addEventListener
){if(document.addEventListener(&#x22;DOMContentLoaded&#x22;,
d.pageLoaded,!1),window.addEventListener(&#x22;load&#x22;,d.pageLoaded,!1),!document.readyState)ea=!0,document.readyState=&#x22;
loading&#x22;}else window.attachEvent&#x26;&#x26;(window.attachEvent(&#x22;onload&#x22;,d.pageLoaded),self===self.top&#x26;&#x26
;(Q=setInterval(function(){try{document.body&#x26;&#x26;(document.documentElement.doScroll(&#x22;left&#x22;),d.pageLoaded())}catch
(a){}},30)));document.readyState===&#x22;complete&#x22;&#x26;&#x26;d.pageLoaded()}d(q);if(d.isAsync&#x26;&#x26;typeof setTimeout
!==&#x22;undefined&#x22;)w=i.contexts[q.context||&#x22;_&#x22;],w.requireWait=!0,setTimeout(function(){w.requireWait=
!1;w.takeGlobalQueue();w.jQueryCheck();w.scriptCount||w.<span class="apidocCodeKeywordSpan">resume</span>();d.checkReadyState()},
0)}})();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.setEncoding" id="apidoc.element.follow.Changes.prototype.setEncoding">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setEncoding
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEncoding = function (encoding) {
  var self = this
  self.encoding = encoding // TODO
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.setHeader" id="apidoc.element.follow.Changes.prototype.setHeader">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setHeader
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setHeader = function (key, val) {
  var self = this
  self.headers[key] = val
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.write" id="apidoc.element.follow.Changes.prototype.write">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (data, encoding) {
  var self = this

  data = self.normalize_data(data, encoding)
  if(typeof data != &#x27;string&#x27;)
    return // Looks like normalize_data emitted an error.

  if(self.feed === &#x27;longpoll&#x27;)
    return self.write_longpoll(data)
  else if(self.feed === &#x27;continuous&#x27;)
    return self.write_continuous(data)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//    limitations under the License.

var lib = require(&#x27;./lib&#x27;)
, couch_changes = require(&#x27;./api&#x27;)
;

function puts(str) {
process.stdout.<span class="apidocCodeKeywordSpan">write</span>(str + &#x22;\n&#x22;);
}

function main() {
var db = require.isBrowser ? (process.env.db || &#x27;/_users&#x27;) : process.argv[2];
puts(&#x27;Watching: &#x27; + db);

var feed = new couch_changes.Feed();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.write_continuous" id="apidoc.element.follow.Changes.prototype.write_continuous">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_continuous
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write_continuous = function (data) {
  var self = this

  var offset, json, change
    , buf = (self.buf || &#x22;&#x22;) + data

  self.log.debug(&#x27;write: &#x27; + util.inspect({&#x27;data&#x27;:data, &#x27;buf&#x27;:buf}))

  // Buf could have 0, 1, or many JSON objects in it.
  while((offset = buf.indexOf(&#x22;\n&#x22;)) &#x3e;= 0) {
    json = buf.substr(0, offset);
    buf = buf.substr(offset + 1);
    self.log.debug(&#x27;JSON: &#x27; + util.inspect(json))

    // Heartbeats (empty strings) are fine, but otherwise confirm valid JSON.
    if(json === &#x22;&#x22;)
      ;

    else if(json[0] !== &#x27;{&#x27;)
      return self.error(new Error(&#x27;Non-object JSON data: &#x27; + json))

    else {
      try { change = JSON.parse(json) }
      catch (er) { return self.error(er) }

      self.log.debug(&#x27;Object: &#x27; + util.inspect(change))
      json = JSON.stringify(change)
    }

    // Change (or heartbeat) looks good.
    self.changes.push(json)
  }

  // Remember the unused data and send all known good changes (or heartbeats). The data (or heartbeat)
  // event listeners may call .pause() so remember the is_sending state now before calling them.
  var was_sending = self.is_sending
  self.buf = buf
  self.emit_changes()
  return was_sending
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
data = self.normalize_data(data, encoding)
if(typeof data != &#x27;string&#x27;)
  return // Looks like normalize_data emitted an error.

if(self.feed === &#x27;longpoll&#x27;)
  return self.write_longpoll(data)
else if(self.feed === &#x27;continuous&#x27;)
  return self.<span class="apidocCodeKeywordSpan">write_continuous</span>(data)
}


Changes.prototype.write_longpoll = function(data) {
var self = this

if(self.buf === null)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.write_longpoll" id="apidoc.element.follow.Changes.prototype.write_longpoll">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_longpoll
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write_longpoll = function (data) {
  var self = this

  if(self.buf === null)
    self.buf = []

  self.buf.push(data)
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var self = this

data = self.normalize_data(data, encoding)
if(typeof data != &#x27;string&#x27;)
  return // Looks like normalize_data emitted an error.

if(self.feed === &#x27;longpoll&#x27;)
  return self.<span class="apidocCodeKeywordSpan">write_longpoll</span>(data)
else if(self.feed === &#x27;continuous&#x27;)
  return self.write_continuous(data)
}


Changes.prototype.write_longpoll = function(data) {
var self = this
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed" id="apidoc.module.follow.Feed">module follow.Feed</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.Feed" id="apidoc.element.follow.Feed.Feed">
        function <span class="apidocSignatureSpan">follow.</span>Feed
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Feed(opts) {
  var self = this;
  EventEmitter.call(self);

  opts = opts || {}

  self.feed = &#x27;continuous&#x27;;
  self.heartbeat         = opts.heartbeat || DEFAULT_HEARTBEAT;
  self.max_retry_seconds = opts.max_retry_seconds || DEFAULT_MAX_RETRY_SECONDS;
  self.inactivity_ms = null;
  self.initial_retry_delay = opts.initial_retry_delay || INITIAL_RETRY_DELAY;
  self.response_grace_time = opts.response_grace_time || RESPONSE_GRACE_TIME;

  self.headers = {};
  self.request = opts.request || {} // Extra options for potentially future versions of request. The caller can supply them.

  self.since = 0;
  self.is_paused = false
  self.caught_up = false
  self.retry_delay = self.initial_retry_delay;

  self.query_params = {}; // Extra `req.query` values for filter functions

  if(typeof opts === &#x27;string&#x27;)
    opts = {&#x27;db&#x27;: opts};

  Object.keys(opts).forEach(function(key) {
    if (typeof self[key] !== &#x27;function&#x27;)
      self[key] = opts[key];
  })

  self.pending = { request     : null
                 , activity_at : null
                 };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
process.stdout.write(str + &#x22;\n&#x22;);
}

function main() {
var db = require.isBrowser ? (process.env.db || &#x27;/_users&#x27;) : process.argv[2];
puts(&#x27;Watching: &#x27; + db);

var feed = new couch_changes.<span class="apidocCodeKeywordSpan">Feed</span>();
feed.db = db;
feed.since = (process.env.since === &#x27;now&#x27;) ? &#x27;now&#x27; : parseInt(process.env.since || &#x27;0&#x27;);

feed.heartbeat = (process.env.heartbeat || &#x27;3000&#x27;).replace(/s$/, &#x27;000&#x27;);
feed.heartbeat = parseInt(feed.heartbeat);

if(require.isBrowser)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.super_" id="apidoc.element.follow.Feed.super_">
        function <span class="apidocSignatureSpan">follow.Feed.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype" id="apidoc.module.follow.Feed.prototype">module follow.Feed.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.check_for_catchup" id="apidoc.element.follow.Feed.prototype.check_for_catchup">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>check_for_catchup
        <span class="apidocSignatureSpan">(seq)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function check_for_catchup(seq) {
  var self = this

  if (self.is_db_updates)
    return
  if(self.caught_up)
    return
  if(seq &#x3c; self.original_db_seq)
    return

  self.caught_up = true
  self.emit(&#x27;catchup&#x27;, seq)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(result) {
  self.log.debug(&#x27;Builtin filter PASS for change: &#x27; + change.seq);
  return self.on_good_change(change);
} else {
  self.log.debug(&#x27;Builtin filter FAIL for change: &#x27; + change.seq);

  // Even with a filtered change, a &#x22;catchup&#x22; event might still be appropriate.
  self.<span class="apidocCodeKeywordSpan">check_for_catchup</span>(change.seq)
}
}

Feed.prototype.on_good_change = function on_good_change(change) {
var self = this;

if(self.inactivity_ms &#x26;&#x26; !self.inactivity_timer)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.confirm" id="apidoc.element.follow.Feed.prototype.confirm">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>confirm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function confirm_feed() {
  var self = this;

  self.db_safe = lib.scrub_creds(self.db);

  var endpoint = self.is_db_updates ? &#x27;server&#x27; : &#x27;database&#x27;;

  self.log.debug(&#x27;Checking &#x27; + endpoint + &#x27;: &#x27; + self.db_safe);

  var confirm_timeout = self.heartbeat * 3; // Give it time to look up the name, connect, etc.
  var timeout_id = setTimeout(function() {
    return self.die(new Error(&#x27;Timeout confirming &#x27; + endpoint + &#x27;: &#x27; + self.db_safe));
  }, confirm_timeout);

  var headers = lib.JP(lib.JS(self.headers));
  headers.accept = &#x27;application/json&#x27;;

  var uri = self.is_db_updates ? self.db.replace(/\/_db_updates$/, &#x27;&#x27;) : self.db;
  var req = {&#x27;uri&#x27;:uri, &#x27;headers&#x27;:headers}
  Object.keys(self.request).forEach(function(key) {
    req[key] = self.request[key];
  })

  req = request(req, db_response)
  self.emit(&#x27;confirm_request&#x27;, req)

  function db_response(er, resp, body) {
    clearTimeout(timeout_id);

    if(er)
      return self.die(er);

    var db;
    try {
      db = JSON.parse(body)
    } catch(json_er) {
      return self.emit(&#x27;error&#x27;, json_er)
    }

    if(!self.is_db_updates &#x26;&#x26; !self.dead &#x26;&#x26; (!db.db_name || !db.instance_start_time))
      return self.emit(&#x27;error&#x27;, new Error(&#x27;Bad DB response: &#x27; + body));

    if(self.is_db_updates &#x26;&#x26; !self.dead &#x26;&#x26; !db.couchdb)
      return self.emit(&#x27;error&#x27;, new Error(&#x27;Bad server response: &#x27; + body));

    if (!self.is_db_updates)
      self.original_db_seq = db.update_seq

    self.log.debug(&#x27;Confirmed &#x27; + endpoint + &#x27;: &#x27; + self.db_safe);
    self.emit(&#x27;confirm&#x27;, db);

    if(self.since == &#x27;now&#x27;) {
      self.log.debug(&#x27;Query since &#x22;now&#x22; is the same as query since -1&#x27;)
      self.since = -1
    }

    if(self.since == -1) {
      self.log.debug(&#x27;Query since &#x27;+self.since+&#x27; will start at &#x27; + db.update_seq)
      self.since = db.update_seq
    } else if(self.since &#x3c; 0) {
      if(isNaN(db.update_seq))
        return self.emit(&#x27;error&#x27;, new Error(&#x27;DB requires specific id in &#x22;since&#x22;&#x27;));

      self.log.debug(&#x27;Query since &#x27;+self.since+&#x27; will start at &#x27; + (db.update_seq + self.since + 1))
      self.since = db.update_seq + self.since + 1
    }

    // If the next change would come after the current update_seq, just fake a catchup event now.
    if(self.original_db_seq == self.since) {
      self.caught_up = true
      self.emit(&#x27;catchup&#x27;, db.update_seq)
    }

    return self.query();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(typeof self.heartbeat !== &#x27;number&#x27;)
  throw new Error(&#x27;Required &#x22;heartbeat&#x22; value&#x27;);

self.log = lib.log4js.getLogger(self.db);
self.log.setLevel(process.env.follow_log_level || &#x22;info&#x22;);

self.emit(&#x27;start&#x27;);
return self.<span class="apidocCodeKeywordSpan">confirm</span>();
}

Feed.prototype.confirm = function confirm_feed() {
var self = this;

self.db_safe = lib.scrub_creds(self.db);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.die" id="apidoc.element.follow.Feed.prototype.die">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>die
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">die = function (er) {
  var self = this;

  if(er)
    self.log.fatal(&#x27;Fatal error: &#x27; + er.stack);

  // Warn code executing later that death has occured.
  self.dead = true

  clearTimeout(self.retry_timer)
  clearTimeout(self.inactivity_timer)
  clearTimeout(self.pending.wait_timer)

  self.inactivity_timer = null
  self.pending.wait_timer = null

  var req = self.pending.request;
  self.pending.request = null;
  if(req) {
    self.log.debug(&#x27;Destroying req &#x27; + req.id());
    destroy_req(req);
  }

  if(er)
    self.emit(&#x27;error&#x27;, er);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var endpoint = self.is_db_updates ? &#x27;server&#x27; : &#x27;database&#x27;;

self.log.debug(&#x27;Checking &#x27; + endpoint + &#x27;: &#x27; + self.db_safe);

var confirm_timeout = self.heartbeat * 3; // Give it time to look up the name, connect, etc.
var timeout_id = setTimeout(function() {
  return self.<span class="apidocCodeKeywordSpan">die</span>(new Error(&#x27;Timeout confirming &#x27; + endpoint + &#x27;: &#x27
; + self.db_safe));
}, confirm_timeout);

var headers = lib.JP(lib.JS(self.headers));
headers.accept = &#x27;application/json&#x27;;

var uri = self.is_db_updates ? self.db.replace(/\/_db_updates$/, &#x27;&#x27;) : self.db;
var req = {&#x27;uri&#x27;:uri, &#x27;headers&#x27;:headers}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.follow" id="apidoc.element.follow.Feed.prototype.follow">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>follow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function follow_feed() {
  var self = this;

  self.db = self.db || self.url || self.uri
  delete self.url
  delete self.uri

  if(!self.db)
    throw new Error(&#x27;Database URL required&#x27;);

  if (self.db.match(/\/_db_updates$/))
    self.is_db_updates = true;

  if(self.is_db_updates)
    delete self.since;

  if(self.feed !== &#x27;continuous&#x27; &#x26;&#x26; self.feed !== &#x27;longpoll&#x27;)
    throw new Error(&#x27;The only valid feed options are &#x22;continuous&#x22; and &#x22;longpoll&#x22;&#x27;);

  if(typeof self.heartbeat !== &#x27;number&#x27;)
    throw new Error(&#x27;Required &#x22;heartbeat&#x22; value&#x27;);

  self.log = lib.log4js.getLogger(self.db);
  self.log.setLevel(process.env.follow_log_level || &#x22;info&#x22;);

  self.emit(&#x27;start&#x27;);
  return self.confirm();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

process.on(&#x27;uncaughtException&#x27;, function(er) {
  puts(&#x27;========= UNCAUGHT EXCEPTION; This is bad&#x27;);
  puts(er.stack);
  setTimeout(function() { process.exit(1) }, 100);
})

feed.<span class="apidocCodeKeywordSpan">follow</span>();
}

exports.main = main;
if(!require.isBrowser &#x26;&#x26; process.argv[1] == module.filename)
main();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.got_activity" id="apidoc.element.follow.Feed.prototype.got_activity">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>got_activity
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">got_activity = function () {
  var self = this

  if (self.dead)
    return

  //
  // We may not have a wait_timer so just clear it and null it out if it does
  // exist
  //
  clearTimeout(self.pending.wait_timer)
  self.pending.wait_timer = null
  self.pending.activity_at = new Date
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.log.warn(&#x27;No pending request to resume&#x27;)
}


Feed.prototype.on_couch_heartbeat = function on_couch_heartbeat() {
var self = this

self.<span class="apidocCodeKeywordSpan">got_activity</span>()
if(self.dead)
  return self.log.debug(&#x27;Skip heartbeat processing for dead feed&#x27;)

self.emit(&#x27;heartbeat&#x27;)

if(self.dead)
  return self.log.debug(&#x27;No wait: heartbeat listener stopped this feed&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_change" id="apidoc.element.follow.Feed.prototype.on_change">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_change
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_change(change) {
  var self = this;

  if(!self.is_db_updates &#x26;&#x26; !change.seq)
    return self.die(new Error(&#x27;No seq value in change: &#x27; + lib.JS(change)));

  if(!self.is_db_updates &#x26;&#x26; change.seq == self.since) {
    self.log.debug(&#x27;Bad seq value &#x27; + change.seq + &#x27; since=&#x27; + self.since);
    return destroy_req(self.pending.request);
  }

  if(typeof self.filter !== &#x27;function&#x27;)
    return self.on_good_change(change);

  var req = lib.JDUP({&#x27;query&#x27;: self.pending.request.changes_query});
  var filter_args;

  if (self.is_db_updates) {
    if(!change.db_name || !change.type)
      return self.die(new Error(&#x27;Internal _db_updates filter needs .db_name and .type in change &#x27;, change));
    filter_args = [change.db_name, change.type, req];
  } else {
    if(!change.doc)
      return self.die(new Error(&#x27;Internal filter needs .doc in change &#x27; + change.seq));

    // Don&#x27;t let the filter mutate the real data.
    var doc = lib.JDUP(change.doc);
    filter_args = [doc, req];
  }
  var result = false;
  try {
    result = self.filter.apply(null, filter_args);
  } catch (er) {
    self.log.debug(&#x27;Filter error&#x27;, er);
  }

  result = (result &#x26;&#x26; true) || false;
  if(result) {
    self.log.debug(&#x27;Builtin filter PASS for change: &#x27; + change.seq);
    return self.on_good_change(change);
  } else {
    self.log.debug(&#x27;Builtin filter FAIL for change: &#x27; + change.seq);

    // Even with a filtered change, a &#x22;catchup&#x22; event might still be appropriate.
    self.check_for_catchup(change.seq)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  del_er.last_seq = change.last_seq
  return self.die(del_er)
}

if(!self.is_db_updates &#x26;&#x26; !change.seq)
  return self.die(new Error(&#x27;Change has no .seq field: &#x27; + JSON.stringify(change)))

self.<span class="apidocCodeKeywordSpan">on_change</span>(change)

// on_change() might work its way all the way to a &#x22;change&#x22; event, and the listener
// might call .stop(), which means among other things that no more events are desired.
// The die() code sets a self.dead flag to indicate this.
if(self.dead)
  return self.log.debug(&#x27;No wait: change listener stopped this feed&#x27;)
self.wait()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_data" id="apidoc.element.follow.Feed.prototype.on_couch_data">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_data
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_data(change) {
  var self = this;
  self.log.debug(&#x27;Data from &#x27; + self.pending.request.id());

  self.got_activity()
  if(self.dead)
    return self.log.debug(&#x27;Skip data processing for dead feed&#x27;)

  // The changes stream guarantees that this data is valid JSON.
  change = JSON.parse(change)

  //self.log.debug(&#x27;Object:\n&#x27; + util.inspect(change));
  if(!self.is_db_updates &#x26;&#x26; &#x27;last_seq&#x27; in change) {
    self.log.warn(&#x27;Stopping upon receiving a final message: &#x27; + JSON.stringify(change))
    var del_er = new Error(&#x27;Database deleted after change: &#x27; + change.last_seq)
    del_er.deleted = true
    del_er.last_seq = change.last_seq
    return self.die(del_er)
  }

  if(!self.is_db_updates &#x26;&#x26; !change.seq)
    return self.die(new Error(&#x27;Change has no .seq field: &#x27; + JSON.stringify(change)))

  self.on_change(change)

  // on_change() might work its way all the way to a &#x22;change&#x22; event, and the listener
  // might call .stop(), which means among other things that no more events are desired.
  // The die() code sets a self.dead flag to indicate this.
  if(self.dead)
    return self.log.debug(&#x27;No wait: change listener stopped this feed&#x27;)
  self.wait()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_end" id="apidoc.element.follow.Feed.prototype.on_couch_end">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_end() {
  var self = this;

  self.log.debug(&#x27;Changes feed ended &#x27; + self.pending.request.id());
  self.pending.request = null;
  return self.retry();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_error" id="apidoc.element.follow.Feed.prototype.on_couch_error">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_error
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_error(er) {
  var self = this;

  self.log.debug(&#x27;Changes query eror: &#x27; + lib.JS(er.stack));
  return self.retry();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_heartbeat" id="apidoc.element.follow.Feed.prototype.on_couch_heartbeat">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_heartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_heartbeat() {
  var self = this

  self.got_activity()
  if(self.dead)
    return self.log.debug(&#x27;Skip heartbeat processing for dead feed&#x27;)

  self.emit(&#x27;heartbeat&#x27;)

  if(self.dead)
    return self.log.debug(&#x27;No wait: heartbeat listener stopped this feed&#x27;)
  self.wait()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_good_change" id="apidoc.element.follow.Feed.prototype.on_good_change">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_good_change
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_good_change(change) {
  var self = this;

  if(self.inactivity_ms &#x26;&#x26; !self.inactivity_timer)
    return self.die(new Error(&#x27;Cannot find inactivity timer during change&#x27;));

  clearTimeout(self.inactivity_timer);
  self.inactivity_timer = null;
  if(self.inactivity_ms)
    self.inactivity_timer = setTimeout(function() { self.on_inactivity() }, self.inactivity_ms);

  self.change_at = new Date;

  if(!self.is_db_updates)
    self.since = change.seq;

  self.emit(&#x27;change&#x27;, change);

  self.check_for_catchup(change.seq)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if(!self.is_db_updates &#x26;&#x26; change.seq == self.since) {
  self.log.debug(&#x27;Bad seq value &#x27; + change.seq + &#x27; since=&#x27; + self.since);
  return destroy_req(self.pending.request);
}

if(typeof self.filter !== &#x27;function&#x27;)
  return self.<span class="apidocCodeKeywordSpan">on_good_change</span>(change);

var req = lib.JDUP({&#x27;query&#x27;: self.pending.request.changes_query});
var filter_args;

if (self.is_db_updates) {
  if(!change.db_name || !change.type)
    return self.die(new Error(&#x27;Internal _db_updates filter needs .db_name and .type in change &#x27;, change));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_inactivity" id="apidoc.element.follow.Feed.prototype.on_inactivity">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_inactivity
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_inactivity() {
  var self = this;
  var now = new Date;
  var elapsed_ms = now - self.change_at;
  var elapsed_s  = elapsed_ms / 1000;

  //
  // Since this is actually not fatal, lets just totally reset and start a new
  // request, JUST in case something was bad.
  //
  self.log.debug(&#x27;Req &#x27; + self.pending.request.id() + &#x27; made no changes for &#x27; + elapsed_s + &#x27;s&#x27;);
  return self.restart();

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.resume()

// The inactivity timer is for time between *changes*, or time between the
// initial connection and the first change. Therefore it goes here.
self.change_at = now;
if(self.inactivity_ms) {
  clearTimeout(self.inactivity_timer);
  self.inactivity_timer = setTimeout(function() { self.<span class="apidocCodeKeywordSpan">on_inactivity</span>() }, self.inactivity_ms
);
}

changes_stream.on(&#x27;heartbeat&#x27;, handler_for(&#x27;heartbeat&#x27;))
changes_stream.on(&#x27;error&#x27;, handler_for(&#x27;error&#x27;))
changes_stream.on(&#x27;data&#x27;, handler_for(&#x27;data&#x27;))
changes_stream.on(&#x27;end&#x27;, handler_for(&#x27;end&#x27;))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_timeout" id="apidoc.element.follow.Feed.prototype.on_timeout">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_timeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_timeout() {
  var self = this;
  if (self.dead)
    return self.log.debug(&#x27;No timeout: change listener stopped this feed&#x27;);

  self.log.debug(&#x27;Timeout&#x27;)

  var now = new Date;
  var elapsed_ms = now - self.pending.activity_at;

  self.emit(&#x27;timeout&#x27;, {elapsed_ms:elapsed_ms, heartbeat:self.heartbeat, id:self.pending.request.id()});

<span class="apidocCodeCommentSpan">  /*
  var msg = &#x27; for timeout after &#x27; + elapsed_ms + &#x27;ms; heartbeat=&#x27; + self.heartbeat;
  if(!self.pending.request.id)
    self.log.warn(&#x27;Closing req (no id) &#x27; + msg + &#x27; req=&#x27; + util.inspect(self.pending.request));
  else
    self.log.warn(&#x27;Closing req &#x27; + self.pending.request.id() + msg);
  */
</span>
  destroy_req(self.pending.request);
  self.retry()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var req_id = self.pending.request &#x26;&#x26; self.pending.request.id()
var msg = &#x27;Req &#x27; + req_id + &#x27; timeout=&#x27; + timeout_ms;
if(self.inactivity_ms)
  msg += &#x27;, inactivity=&#x27; + self.inactivity_ms;
msg += &#x27;: &#x27; + self.db_safe;

self.log.debug(msg);
self.pending.wait_timer = setTimeout(function() { self.<span class="apidocCodeKeywordSpan">on_timeout</span>() }, timeout_ms);
}

Feed.prototype.got_activity = function() {
var self = this

if (self.dead)
  return
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.pause" id="apidoc.element.follow.Feed.prototype.pause">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  var self = this
    , was_paused = self.is_paused

  // Emit pause after pausing the stream, to allow listeners to react.
  self.is_paused = true
  if(self.pending &#x26;&#x26; self.pending.request &#x26;&#x26; self.pending.request.pause)
    self.pending.request.pause()
  else
    self.log.warn(&#x27;No pending request to pause&#x27;)

  if(!was_paused)
    self.emit(&#x27;pause&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var now = new Date;
self.pending.request = changes_stream;
self.pending.activity_at = now;
self.pending.wait_timer  = null;

// Just re-run the pause or resume to do the needful on changes_stream (self.pending.request).
if(self.is_paused)
  self.<span class="apidocCodeKeywordSpan">pause</span>()
else
  self.resume()

// The inactivity timer is for time between *changes*, or time between the
// initial connection and the first change. Therefore it goes here.
self.change_at = now;
if(self.inactivity_ms) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.prep" id="apidoc.element.follow.Feed.prototype.prep">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>prep
        <span class="apidocSignatureSpan">(changes_stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prep_request(changes_stream) {
  var self = this;

  var now = new Date;
  self.pending.request = changes_stream;
  self.pending.activity_at = now;
  self.pending.wait_timer  = null;

  // Just re-run the pause or resume to do the needful on changes_stream (self.pending.request).
  if(self.is_paused)
    self.pause()
  else
    self.resume()

  // The inactivity timer is for time between *changes*, or time between the
  // initial connection and the first change. Therefore it goes here.
  self.change_at = now;
  if(self.inactivity_ms) {
    clearTimeout(self.inactivity_timer);
    self.inactivity_timer = setTimeout(function() { self.on_inactivity() }, self.inactivity_ms);
  }

  changes_stream.on(&#x27;heartbeat&#x27;, handler_for(&#x27;heartbeat&#x27;))
  changes_stream.on(&#x27;error&#x27;, handler_for(&#x27;error&#x27;))
  changes_stream.on(&#x27;data&#x27;, handler_for(&#x27;data&#x27;))
  changes_stream.on(&#x27;end&#x27;, handler_for(&#x27;end&#x27;))

  return self.wait();

  function handler_for(ev) {
    var name = &#x27;on_couch_&#x27; + ev;
    var inner_handler = self[name];

    return handle_confirmed_req_event;
    function handle_confirmed_req_event() {
      if(self.pending.request === changes_stream)
        return inner_handler.apply(self, arguments);

      if(!changes_stream.created_at)
        return self.die(new Error(&#x22;Received data from unknown request&#x22;)); // Pretty sure this is impossible.

      var s_to_now = (new Date() - changes_stream.created_at) / 1000;
      var s_to_req = &#x27;[no req]&#x27;;
      if(self.pending.request)
        s_to_req = (self.pending.request.created_at - changes_stream.created_at) / 1000;

      var msg = &#x27;: &#x27; + changes_stream.id() + &#x27; to_req=&#x27; + s_to_req + &#x27;s, to_now=&#x27; + s_to_now + &#x27;s&#x27;;

      if(ev == &#x27;end&#x27; || ev == &#x27;data&#x27; || ev == &#x27;heartbeat&#x27;) {
        self.log.debug(&#x27;Old &#x22;&#x27; + ev + &#x27;&#x22;: &#x27; + changes_stream.id())
        return destroy_req(changes_stream)
      }

      self.log.warn(&#x27;Old &#x22;&#x27;+ev+&#x27;&#x22;&#x27; + msg);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  changes_stream.log = lib.log4js.getLogger(&#x27;stream &#x27; + self.db)
  changes_stream.log.setLevel(self.log.level.levelStr)
  changes_stream.feed = self.feed
  feed_request.pipe(changes_stream)

  changes_stream.created_at = now
  changes_stream.id = function() { return feed_id }
  return self.<span class="apidocCodeKeywordSpan">prep</span>(changes_stream)
}
}

Feed.prototype.prep = function prep_request(changes_stream) {
var self = this;

var now = new Date;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.query" id="apidoc.element.follow.Feed.prototype.query">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>query
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query_feed() {
  var self = this;

  var query_params = JSON.parse(JSON.stringify(self.query_params));

  FEED_PARAMETERS.forEach(function(key) {
    if(key in self)
      query_params[key] = self[key];
  })

  if(typeof query_params.filter !== &#x27;string&#x27;)
    delete query_params.filter;

  if(typeof self.filter === &#x27;function&#x27; &#x26;&#x26; !query_params.include_docs) {
    self.log.debug(&#x27;Enabling include_docs for client-side filter&#x27;);
    query_params.include_docs = true;
  }

  // Limit the response size for longpoll.
  var poll_size = 100;
  if(query_params.feed == &#x27;longpoll&#x27; &#x26;&#x26; (!query_params.limit || query_params.limit &#x3e; poll_size))
    query_params.limit = poll_size;

  var feed_url = self.db + (self.is_db_updates ? &#x27;&#x27; : &#x27;/_changes&#x27;) + &#x27;?&#x27; + querystring.stringify(query_params);

  self.headers.accept = self.headers.accept || &#x27;application/json&#x27;;
  var req = { method : &#x27;GET&#x27;
            , uri    : feed_url
            , headers: self.headers
            , encoding: &#x27;utf-8&#x27;
            }

  req.changes_query = query_params;
  Object.keys(self.request).forEach(function(key) {
    req[key] = self.request[key];
  })

  var now = new Date
    , feed_ts = lib.JDUP(now)
    , feed_id = process.env.follow_debug ? feed_ts.match(/\.(\d\d\d)Z$/)[1] : feed_ts

  self.log.debug(&#x27;Feed query &#x27; + feed_id + &#x27;: &#x27; + lib.scrub_creds(feed_url))
  var feed_request = request(req)

  feed_request.on(&#x27;response&#x27;, function(res) {
    self.log.debug(&#x27;Remove feed from agent pool: &#x27; + feed_id)
    feed_request.req.socket.emit(&#x27;agentRemove&#x27;)

    // Simulate the old onResponse option.
    on_feed_response(null, res, res.body)
  })

  feed_request.on(&#x27;error&#x27;, on_feed_response)

  // The response headers must arrive within one heartbeat.
  var response_timer = setTimeout(response_timed_out, self.heartbeat + self.response_grace_time)
    , timed_out = false

  return self.emit(&#x27;query&#x27;, feed_request)

  function response_timed_out() {
    self.log.debug(&#x27;Feed response timed out: &#x27; + feed_id)
    timed_out = true
    return self.retry()
  }

  function on_feed_response(er, resp, body) {
    clearTimeout(response_timer)

    if((resp !== undefined &#x26;&#x26; resp.body) || body)
      return self.die(new Error(&#x27;Cannot handle a body in the feed response: &#x27; + lib.JS(resp.body || body)))

    if(timed_out) {
      self.log.debug(&#x27;Ignoring late response: &#x27; + feed_id);
      return destroy_response(resp);
    }

    if(er) {
      self.log.debug(&#x27;Request error &#x27; + feed_id + &#x27;: &#x27; + er.stack);
      destroy_response(resp);
      return self.retry();
    }

    if(resp.statusCode !== 200) {
      self.log.debug(&#x27;Bad changes response &#x27; + feed_id + &#x27;: &#x27; + resp.statusCode);
      destroy_response(resp);
      return self.retry();
    }

    self.log.debug(&#x27;Good response: &#x27; + feed_id);
    self.retry_delay = self.initial_retry_delay;

    self.emit(&#x27;response&#x27;, resp);

    var changes_stream = new Changes
    changes_stream.log = lib.log4js.getLogger(&#x27;stream &#x27; + self.db)
    changes_stream.log.setLevel(self.log.level.levelStr)
    changes_stream.feed = self.feed
    feed_request.pipe(changes_stream)

    changes_stream.created_at = now
    changes_stream.id = function() { return feed_id }
    return self.prep(changes_stream)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // If the next change would come after the current update_seq, just fake a catchup event now.
  if(self.original_db_seq == self.since) {
    self.caught_up = true
    self.emit(&#x27;catchup&#x27;, db.update_seq)
  }

  return self.<span class="apidocCodeKeywordSpan">query</span>();
}
}

Feed.prototype.query = function query_feed() {
var self = this;

var query_params = JSON.parse(JSON.stringify(self.query_params));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.restart" id="apidoc.element.follow.Feed.prototype.restart">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>restart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function restart() {
  var self = this

  self.emit(&#x27;restart&#x27;)

  // Kill ourselves and then start up once again
  self.stop()
  self.dead = false
  self.start()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var elapsed_s  = elapsed_ms / 1000;

//
// Since this is actually not fatal, lets just totally reset and start a new
// request, JUST in case something was bad.
//
self.log.debug(&#x27;Req &#x27; + self.pending.request.id() + &#x27; made no changes for &#x27; + elapsed_s + &#x27;s&#x27;);
return self.<span class="apidocCodeKeywordSpan">restart</span>();

}

Feed.prototype.restart = function restart() {
var self = this

self.emit(&#x27;restart&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.resume" id="apidoc.element.follow.Feed.prototype.resume">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  var self = this
    , was_paused = self.is_paused

  // Emit resume before resuming the data feed, to allow listeners to prepare.
  self.is_paused = false
  if(was_paused)
    self.emit(&#x27;resume&#x27;)

  if(self.pending &#x26;&#x26; self.pending.request &#x26;&#x26; self.pending.request.resume)
    self.pending.request.resume()
  else
    self.log.warn(&#x27;No pending request to resume&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
d.configure(i);return d.require(a,c)};d.config=function(a){return d(a)};typeof require===&#x22;undefined&#x22;&#x26;&#x26;(require
=d);d.toUrl=function(a){return z._.toUrl(a)};d.version=&#x22;0.26.0&#x22;;d.isArray=E;d.isFunction=M;d.mixin=V;d.jsExtRegExp=/^\/|:|\?|\.js$/;i=d.s={contexts:z,skipAsync:{},isPageLoaded:!B,readyCalls:[]};if(d.isAsync=d.isBrowser=B)if(u=i.head=document.getElementsByTagName(&#x22;head&#x22;)[0],L=document.getElementsByTagName(&#x22;base&#x22;)[0])u=i.head=L.parentNode;d.onError=function(a){throw a;};d.load=function(a,c,
g){var e=a.loaded;e[c]||(e[c]=!1);a.scriptCount+=1;d.attach(g,a,c);if(a.jQuery&#x26;&#x26;!a.jQueryIncremented)W(a.jQuery,!0),a.
jQueryIncremented=!0};define=d.def=function(a,c,g){var e,i;typeof a!==&#x22;string&#x22;&#x26;&#x26;(g=c,c=a,a=null);d.isArray(c
)||(g=c,c=[]);!a&#x26;&#x26;!c.length&#x26;&#x26;d.isFunction(g)&#x26;&#x26;g.length&#x26;&#x26;(g.toString().replace(ma,&#x22;&#
x22;).replace(na,function(a,d){c.push(d)}),c=(g.length===1?[&#x22;require&#x22;]:[&#x22;require&#x22;,&#x22;exports&#x22;,&#x22;
module&#x22;]).concat(c));if(N&#x26;&#x26;(e=I||la()))a||(a=e.getAttribute(&#x22;data-requiremodule&#x22;)),i=z[e.getAttribute(&#
x22;data-requirecontext&#x22;)];
(i?i.defQueue:U).push([a,c,g])};define.amd={multiversion:!0,plugins:!0,jQuery:!0};d.exec=function(a){return eval(a)};d.execCb=function
(a,c,d,e){return c.apply(e,d)};d.onScriptLoad=function(a){var c=a.currentTarget||a.srcElement,g;if(a.type===&#x22;load&#x22;||oa
.test(c.readyState))C=null,a=c.getAttribute(&#x22;data-requirecontext&#x22;),g=c.getAttribute(&#x22;data-requiremodule&#x22;),z[
a].completeLoad(g),c.detachEvent&#x26;&#x26;!da?c.detachEvent(&#x22;onreadystatechange&#x22;,d.onScriptLoad):c.removeEventListener
(&#x22;load&#x22;,d.onScriptLoad,!1)};d.attach=
function(a,c,g,e,q){var j;if(B)return e=e||d.onScriptLoad,j=c&#x26;&#x26;c.config&#x26;&#x26;c.config.xhtml?document.createElementNS
(&#x22;http://www.w3.org/1999/xhtml&#x22;,&#x22;html:script&#x22;):document.createElement(&#x22;script&#x22;),j.type=q||&#x22;text
/javascript&#x22;,j.charset=&#x22;utf-8&#x22;,j.async=!i.skipAsync[a],c&#x26;&#x26;j.setAttribute(&#x22;data-requirecontext&#x22
;,c.contextName),j.setAttribute(&#x22;data-requiremodule&#x22;,g),j.attachEvent&#x26;&#x26;!da?(N=!0,j.attachEvent(&#x22;onreadystatechange
&#x22;,e)):j.addEventListener(&#x22;load&#x22;,e,!1),j.src=a,I=j,L?u.insertBefore(j,L):u.appendChild(j),
I=null,j;else if(ca)e=c.loaded,e[g]=!1,importScripts(a),c.completeLoad(g);return null};if(B){v=document.getElementsByTagName(&#x22
;script&#x22;);for(H=v.length-1;H&#x3e;-1&#x26;&#x26;(A=v[H]);H--){if(!u)u=A.parentNode;if(D=A.getAttribute(&#x22;data-main&#x22
;)){if(!q.baseUrl)v=D.split(&#x22;/&#x22;),A=v.pop(),v=v.length?v.join(&#x22;/&#x22;)+&#x22;/&#x22;:&#x22;./&#x22;,q.baseUrl=v,D
=A.replace(ba,&#x22;&#x22;);q.deps=q.deps?q.deps.concat(D):[D];break}}}i.baseUrl=q.baseUrl;d.pageLoaded=function(){if(!i.isPageLoaded
){i.isPageLoaded=!0;Q&#x26;&#x26;clearInterval(Q);if(ea)document.readyState=&#x22;complete&#x22;;
d.callReady()}};d.checkReadyState=function(){var a=i.contexts,c;for(c in a)if(!(c in J)&#x26;&#x26;a[c].waitCount)return;i.isDone
=!0;d.callReady()};d.callReady=function(){var a=i.readyCalls,c,d,e;if(i.isPageLoaded&#x26;&#x26;i.isDone){if(a.length){i.readyCalls
=[];for(c=0;d=a[c];c++)d()}a=i.contexts;for(e in a)if(!(e in J)&#x26;&#x26;(c=a[e],c.jQueryIncremented))W(c.jQuery,!1),c.jQueryIncremented
=!1}};d.ready=function(a){i.isPageLoaded&#x26;&#x26;i.isDone?a():i.readyCalls.push(a);return d};if(B){if(document.addEventListener
){if(document.addEventListener(&#x22;DOMContentLoaded&#x22;,
d.pageLoaded,!1),window.addEventListener(&#x22;load&#x22;,d.pageLoaded,!1),!document.readyState)ea=!0,document.readyState=&#x22;
loading&#x22;}else window.attachEvent&#x26;&#x26;(window.attachEvent(&#x22;onload&#x22;,d.pageLoaded),self===self.top&#x26;&#x26
;(Q=setInterval(function(){try{document.body&#x26;&#x26;(document.documentElement.doScroll(&#x22;left&#x22;),d.pageLoaded())}catch
(a){}},30)));document.readyState===&#x22;complete&#x22;&#x26;&#x26;d.pageLoaded()}d(q);if(d.isAsync&#x26;&#x26;typeof setTimeout
!==&#x22;undefined&#x22;)w=i.contexts[q.context||&#x22;_&#x22;],w.requireWait=!0,setTimeout(function(){w.requireWait=
!1;w.takeGlobalQueue();w.jQueryCheck();w.scriptCount||w.<span class="apidocCodeKeywordSpan">resume</span>();d.checkReadyState()},
0)}})();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.retry" id="apidoc.element.follow.Feed.prototype.retry">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>retry
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry() {
  var self = this;

  clearTimeout(self.pending.wait_timer);
  self.pending.wait_timer = null;

  self.log.debug(&#x27;Retry since=&#x27; + self.since + &#x27; after &#x27; + self.retry_delay + &#x27;ms &#x27;)
  self.emit(&#x27;retry&#x27;, {since:self.since, after:self.retry_delay, db:self.db_safe});

  self.retry_timer = setTimeout(function() { self.query() }, self.retry_delay);

  var max_retry_ms = self.max_retry_seconds * 1000;
  self.retry_delay *= 2;
  if(self.retry_delay &#x3e; max_retry_ms)
    self.retry_delay = max_retry_ms;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
, timed_out = false

  return self.emit(&#x27;query&#x27;, feed_request)

  function response_timed_out() {
self.log.debug(&#x27;Feed response timed out: &#x27; + feed_id)
timed_out = true
return self.<span class="apidocCodeKeywordSpan">retry</span>()
  }

  function on_feed_response(er, resp, body) {
clearTimeout(response_timer)

if((resp !== undefined &#x26;&#x26; resp.body) || body)
  return self.die(new Error(&#x27;Cannot handle a body in the feed response: &#x27; + lib.JS(resp.body || body)))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.start" id="apidoc.element.follow.Feed.prototype.start">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function follow_feed() {
  var self = this;

  self.db = self.db || self.url || self.uri
  delete self.url
  delete self.uri

  if(!self.db)
    throw new Error(&#x27;Database URL required&#x27;);

  if (self.db.match(/\/_db_updates$/))
    self.is_db_updates = true;

  if(self.is_db_updates)
    delete self.since;

  if(self.feed !== &#x27;continuous&#x27; &#x26;&#x26; self.feed !== &#x27;longpoll&#x27;)
    throw new Error(&#x27;The only valid feed options are &#x22;continuous&#x22; and &#x22;longpoll&#x22;&#x27;);

  if(typeof self.heartbeat !== &#x27;number&#x27;)
    throw new Error(&#x27;Required &#x22;heartbeat&#x22; value&#x27;);

  self.log = lib.log4js.getLogger(self.db);
  self.log.setLevel(process.env.follow_log_level || &#x22;info&#x22;);

  self.emit(&#x27;start&#x27;);
  return self.confirm();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var self = this

  self.emit(&#x27;restart&#x27;)

  // Kill ourselves and then start up once again
  self.stop()
  self.dead = false
  self.<span class="apidocCodeKeywordSpan">start</span>()
}

module.exports = { &#x22;Feed&#x22; : Feed
                 };


/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.stop" id="apidoc.element.follow.Feed.prototype.stop">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>stop
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (val) {
  var self = this
  self.log.debug(&#x27;Stop&#x27;)

  // Die with no errors.
  self.die()
  self.emit(&#x27;stop&#x27;, val);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if(!self.is_db_updates &#x26;&#x26; !change.seq)
    return self.die(new Error(&#x27;Change has no .seq field: &#x27; + JSON.stringify(change)))

  self.on_change(change)

  // on_change() might work its way all the way to a &#x22;change&#x22; event, and the listener
  // might call .<span class="apidocCodeKeywordSpan">stop</span>(), which means among other things that no more events are desired
.
  // The die() code sets a self.dead flag to indicate this.
  if(self.dead)
    return self.log.debug(&#x27;No wait: change listener stopped this feed&#x27;)
  self.wait()
}

Feed.prototype.on_timeout = function on_timeout() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.wait" id="apidoc.element.follow.Feed.prototype.wait">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>wait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wait_for_event() {
  var self = this;
  self.emit(&#x27;wait&#x27;);

  if(self.pending.wait_timer)
    return self.die(new Error(&#x27;wait() called but there is already a wait_timer: &#x27; + self.pending.wait_timer));

  var timeout_ms = self.heartbeat * HEARTBEAT_TIMEOUT_COEFFICIENT;
  var req_id = self.pending.request &#x26;&#x26; self.pending.request.id()
  var msg = &#x27;Req &#x27; + req_id + &#x27; timeout=&#x27; + timeout_ms;
  if(self.inactivity_ms)
    msg += &#x27;, inactivity=&#x27; + self.inactivity_ms;
  msg += &#x27;: &#x27; + self.db_safe;

  self.log.debug(msg);
  self.pending.wait_timer = setTimeout(function() { self.on_timeout() }, timeout_ms);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  changes_stream.on(&#x27;heartbeat&#x27;, handler_for(&#x27;heartbeat&#x27;))
  changes_stream.on(&#x27;error&#x27;, handler_for(&#x27;error&#x27;))
  changes_stream.on(&#x27;data&#x27;, handler_for(&#x27;data&#x27;))
  changes_stream.on(&#x27;end&#x27;, handler_for(&#x27;end&#x27;))

  return self.<span class="apidocCodeKeywordSpan">wait</span>();

  function handler_for(ev) {
var name = &#x27;on_couch_&#x27; + ev;
var inner_handler = self[name];

return handle_confirmed_req_event;
function handle_confirmed_req_event() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.cli" id="apidoc.module.follow.cli">module follow.cli</a></h1>


    <h2>
        <a href="#apidoc.element.follow.cli.main" id="apidoc.element.follow.cli.main">
        function <span class="apidocSignatureSpan">follow.cli.</span>main
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function main() {
  var db = require.isBrowser ? (process.env.db || &#x27;/_users&#x27;) : process.argv[2];
  puts(&#x27;Watching: &#x27; + db);

  var feed = new couch_changes.Feed();
  feed.db = db;
  feed.since = (process.env.since === &#x27;now&#x27;) ? &#x27;now&#x27; : parseInt(process.env.since || &#x27;0&#x27;);

  feed.heartbeat = (process.env.heartbeat || &#x27;3000&#x27;).replace(/s$/, &#x27;000&#x27;);
  feed.heartbeat = parseInt(feed.heartbeat);

  if(require.isBrowser)
    feed.feed = &#x27;longpoll&#x27;;
  if(process.env.host)
    feed.headers.host = process.env.host;
  if(process.env.inactivity)
    feed.inactivity_ms = parseInt(process.env.inactivity);
  if(process.env.limit)
    feed.limit = parseInt(process.env.limit);

  feed.query_params.pid = process.pid;
  feed.filter = process.env.filter || example_filter;
  function example_filter(doc, req) {
    // This is a local filter. It runs on the client side.
    var label = &#x27;Filter &#x27; + (req.query.pid || &#x27;::&#x27;);

    if(process.env.show_doc)
      console.log(label + &#x27; doc: &#x27; + JSON.stringify(doc));
    if(process.env.show_req)
      console.log(label + &#x27; for &#x27; + doc._id + &#x27; req: &#x27; + JSON.stringify(req));
    return true;
  }

  feed.on(&#x27;confirm&#x27;, function() {
    puts(&#x27;Database confirmed: &#x27; + db);
  })

  feed.on(&#x27;change&#x27;, function(change) {
    puts(&#x27;Change:&#x27; + JSON.stringify(change));
  })

  feed.on(&#x27;timeout&#x27;, function(state) {
    var seconds = state.elapsed_ms / 1000;
    var hb = state.heartbeat / 1000;
    puts(&#x27;Timeout after &#x27; + seconds + &#x27;s inactive, heartbeat=&#x27; + hb + &#x27;s&#x27;);
  })

  feed.on(&#x27;retry&#x27;, function(state) {
    if(require.isBrowser)
      puts(&#x27;Long polling since &#x27; + state.since);
    else
      puts(&#x27;Retry since &#x27; + state.since + &#x27; after &#x27; + state.after + &#x27;ms&#x27;);
  })

  feed.on(&#x27;response&#x27;, function() {
    puts(&#x27;Streaming response:&#x27;);
  })

  feed.on(&#x27;error&#x27;, function(er) {
    //console.error(er);
    console.error(&#x27;Changes error ============\n&#x27; + er.stack);
    setTimeout(function() { process.exit(0) }, 100);
  })

  process.on(&#x27;uncaughtException&#x27;, function(er) {
    puts(&#x27;========= UNCAUGHT EXCEPTION; This is bad&#x27;);
    puts(er.stack);
    setTimeout(function() { process.exit(1) }, 100);
  })

  feed.follow();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.eventemitter2" id="apidoc.module.follow.eventemitter2">module follow.eventemitter2</a></h1>


    <h2>
        <a href="#apidoc.element.follow.eventemitter2.EventEmitter2" id="apidoc.element.follow.eventemitter2.EventEmitter2">
        function <span class="apidocSignatureSpan">follow.eventemitter2.</span>EventEmitter2
        <span class="apidocSignatureSpan">(conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter(conf) {
  this._events = new Object;
  configure.call(this, conf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.feed" id="apidoc.module.follow.feed">module follow.feed</a></h1>


    <h2>
        <a href="#apidoc.element.follow.feed.Feed" id="apidoc.element.follow.feed.Feed">
        function <span class="apidocSignatureSpan">follow.feed.</span>Feed
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Feed(opts) {
  var self = this;
  EventEmitter.call(self);

  opts = opts || {}

  self.feed = &#x27;continuous&#x27;;
  self.heartbeat         = opts.heartbeat || DEFAULT_HEARTBEAT;
  self.max_retry_seconds = opts.max_retry_seconds || DEFAULT_MAX_RETRY_SECONDS;
  self.inactivity_ms = null;
  self.initial_retry_delay = opts.initial_retry_delay || INITIAL_RETRY_DELAY;
  self.response_grace_time = opts.response_grace_time || RESPONSE_GRACE_TIME;

  self.headers = {};
  self.request = opts.request || {} // Extra options for potentially future versions of request. The caller can supply them.

  self.since = 0;
  self.is_paused = false
  self.caught_up = false
  self.retry_delay = self.initial_retry_delay;

  self.query_params = {}; // Extra `req.query` values for filter functions

  if(typeof opts === &#x27;string&#x27;)
    opts = {&#x27;db&#x27;: opts};

  Object.keys(opts).forEach(function(key) {
    if (typeof self[key] !== &#x27;function&#x27;)
      self[key] = opts[key];
  })

  self.pending = { request     : null
                 , activity_at : null
                 };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
process.stdout.write(str + &#x22;\n&#x22;);
}

function main() {
var db = require.isBrowser ? (process.env.db || &#x27;/_users&#x27;) : process.argv[2];
puts(&#x27;Watching: &#x27; + db);

var feed = new couch_changes.<span class="apidocCodeKeywordSpan">Feed</span>();
feed.db = db;
feed.since = (process.env.since === &#x27;now&#x27;) ? &#x27;now&#x27; : parseInt(process.env.since || &#x27;0&#x27;);

feed.heartbeat = (process.env.heartbeat || &#x27;3000&#x27;).replace(/s$/, &#x27;000&#x27;);
feed.heartbeat = parseInt(feed.heartbeat);

if(require.isBrowser)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.index" id="apidoc.module.follow.index">module follow.index</a></h1>


    <h2>
        <a href="#apidoc.element.follow.index.JDUP" id="apidoc.element.follow.index.JDUP">
        function <span class="apidocSignatureSpan">follow.index.</span>JDUP
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JDUP = function (obj) { return JSON.parse(JSON.stringify(obj)) }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

req.changes_query = query_params;
Object.keys(self.request).forEach(function(key) {
  req[key] = self.request[key];
})

var now = new Date
  , feed_ts = lib.<span class="apidocCodeKeywordSpan">JDUP</span>(now)
  , feed_id = process.env.follow_debug ? feed_ts.match(/\.(\d\d\d)Z$/)[1] : feed_ts

self.log.debug(&#x27;Feed query &#x27; + feed_id + &#x27;: &#x27; + lib.scrub_creds(feed_url))
var feed_request = request(req)

feed_request.on(&#x27;response&#x27;, function(res) {
  self.log.debug(&#x27;Remove feed from agent pool: &#x27; + feed_id)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.index.JP" id="apidoc.element.follow.index.JP">
        function <span class="apidocSignatureSpan">follow.index.</span>JP
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.log.debug(&#x27;Checking &#x27; + endpoint + &#x27;: &#x27; + self.db_safe);

var confirm_timeout = self.heartbeat * 3; // Give it time to look up the name, connect, etc.
var timeout_id = setTimeout(function() {
  return self.die(new Error(&#x27;Timeout confirming &#x27; + endpoint + &#x27;: &#x27; + self.db_safe));
}, confirm_timeout);

var headers = lib.<span class="apidocCodeKeywordSpan">JP</span>(lib.JS(self.headers));
headers.accept = &#x27;application/json&#x27;;

var uri = self.is_db_updates ? self.db.replace(/\/_db_updates$/, &#x27;&#x27;) : self.db;
var req = {&#x27;uri&#x27;:uri, &#x27;headers&#x27;:headers}
Object.keys(self.request).forEach(function(key) {
  req[key] = self.request[key];
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.index.JS" id="apidoc.element.follow.index.JS">
        function <span class="apidocSignatureSpan">follow.index.</span>JS
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stringify() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.log.debug(&#x27;Checking &#x27; + endpoint + &#x27;: &#x27; + self.db_safe);

var confirm_timeout = self.heartbeat * 3; // Give it time to look up the name, connect, etc.
var timeout_id = setTimeout(function() {
  return self.die(new Error(&#x27;Timeout confirming &#x27; + endpoint + &#x27;: &#x27; + self.db_safe));
}, confirm_timeout);

var headers = lib.JP(lib.<span class="apidocCodeKeywordSpan">JS</span>(self.headers));
headers.accept = &#x27;application/json&#x27;;

var uri = self.is_db_updates ? self.db.replace(/\/_db_updates$/, &#x27;&#x27;) : self.db;
var req = {&#x27;uri&#x27;:uri, &#x27;headers&#x27;:headers}
Object.keys(self.request).forEach(function(key) {
  req[key] = self.request[key];
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.index.clearTimeout" id="apidoc.element.follow.index.clearTimeout">
        function <span class="apidocSignatureSpan">follow.index.</span>clearTimeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearTimeout = function () { return timeouts.clearTimeout.apply(this, arguments) }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.index.scrub_creds" id="apidoc.element.follow.index.scrub_creds">
        function <span class="apidocSignatureSpan">follow.index.</span>scrub_creds
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scrub_creds(url) {
  return url.replace(/^(https?:\/\/)[^:]+:[^@]+@(.*)$/, &#x27;$1$2&#x27;); // Scrub username and password
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.emit(&#x27;start&#x27;);
return self.confirm();
}

Feed.prototype.confirm = function confirm_feed() {
var self = this;

self.db_safe = lib.<span class="apidocCodeKeywordSpan">scrub_creds</span>(self.db);

var endpoint = self.is_db_updates ? &#x27;server&#x27; : &#x27;database&#x27;;

self.log.debug(&#x27;Checking &#x27; + endpoint + &#x27;: &#x27; + self.db_safe);

var confirm_timeout = self.heartbeat * 3; // Give it time to look up the name, connect, etc.
var timeout_id = setTimeout(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.index.setTimeout" id="apidoc.element.follow.index.setTimeout">
        function <span class="apidocSignatureSpan">follow.index.</span>setTimeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTimeout = function () { return timeouts.setTimeout.apply(this, arguments) }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.index.timeouts" id="apidoc.element.follow.index.timeouts">
        function <span class="apidocSignatureSpan">follow.index.</span>timeouts
        <span class="apidocSignatureSpan">(set, clear)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeouts = function (set, clear) {
  timeouts.setTimeout = set
  timeouts.clearTimeout = clear
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.stream" id="apidoc.module.follow.stream">module follow.stream</a></h1>


    <h2>
        <a href="#apidoc.element.follow.stream.Changes" id="apidoc.element.follow.stream.Changes">
        function <span class="apidocSignatureSpan">follow.stream.</span>Changes
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Changes(opts) {
  var self = this
  stream.call(self)

  self.readable = true
  self.writable = true

  self.headers = {}
  self.statusCode = null

  opts = opts || {}
  self.feed = opts.feed || null // &#x22;continuous&#x22; or &#x22;longpoll&#x22;
  self.encoding = opts.encoding || &#x27;utf8&#x27;

  self.log = opts.log
  if(!self.log) {
    self.log = lib.log4js.getLogger(&#x27;change_stream&#x27;)
    self.log.setLevel(DEFS.log_level)
  }

  self.is_sending = true
  self.is_ending = false
  self.is_dead = false

  self.source = null
  self.expect = null
  self.buf = null
  self.changes = []

  self.on(&#x27;pipe&#x27;, function(src) {
    if(!self.source)
      self.source = src
    else {
      var er = new Error(&#x27;Already have a pipe source&#x27;)
      er.source = self.source
      self.error(er)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
