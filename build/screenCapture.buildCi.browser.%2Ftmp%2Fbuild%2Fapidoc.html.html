<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://github.com/iriscouch/follow">follow (v0.12.1)</a>
</h1>
<h4>Extremely robust, fault-tolerant CouchDB changes follower</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow">module follow</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.follow">
            function <span class="apidocSignatureSpan"></span>follow
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes">
            function <span class="apidocSignatureSpan">follow.</span>Changes
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.destroy">
            function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.destroySoon">
            function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.destroySoon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.emit_changes">
            function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.emit_changes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.end">
            function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.end
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.error">
            function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.error
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.normalize_data">
            function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.normalize_data
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.pause">
            function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.resume">
            function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.setEncoding">
            function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.setEncoding
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.setHeader">
            function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.setHeader
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.write">
            function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.write
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.write_continuous">
            function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.write_continuous
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.write_longpoll">
            function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.write_longpoll
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed">
            function <span class="apidocSignatureSpan">follow.</span>Feed
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.check_for_catchup">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.check_for_catchup
            <span class="apidocSignatureSpan">(seq)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.confirm">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.confirm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.die">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.die
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.follow">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.follow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.got_activity">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.got_activity
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_change">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_change
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_data">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_couch_data
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_end">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_couch_end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_error">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_couch_error
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_heartbeat">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_couch_heartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_good_change">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_good_change
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_inactivity">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_inactivity
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_timeout">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_timeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.pause">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.prep">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.prep
            <span class="apidocSignatureSpan">(changes_stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.query">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.query
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.restart">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.restart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.resume">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.retry">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.retry
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.stop">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.stop
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.wait">
            function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.wait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.api">
            function <span class="apidocSignatureSpan">follow.</span>api
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.toString">
            function <span class="apidocSignatureSpan">follow.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>Changes.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>Feed.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>eventemitter2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>feed</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>stream</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes">module follow.Changes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.Changes">
            function <span class="apidocSignatureSpan">follow.</span>Changes
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.super_">
            function <span class="apidocSignatureSpan">follow.Changes.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype">module follow.Changes.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.destroy">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.destroySoon">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroySoon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.emit_changes">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>emit_changes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.end">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>end
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.error">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>error
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.normalize_data">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>normalize_data
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.pause">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.resume">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.setEncoding">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setEncoding
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.setHeader">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setHeader
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.write">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.write_continuous">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_continuous
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.write_longpoll">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_longpoll
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype.destroy">module follow.Changes.prototype.destroy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.destroy.destroy">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype.destroySoon">module follow.Changes.prototype.destroySoon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.destroySoon.destroySoon">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroySoon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype.emit_changes">module follow.Changes.prototype.emit_changes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.emit_changes.emit_changes">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>emit_changes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype.end">module follow.Changes.prototype.end</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.end.end">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>end
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype.error">module follow.Changes.prototype.error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.error.error">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>error
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype.normalize_data">module follow.Changes.prototype.normalize_data</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.normalize_data.normalize_data">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>normalize_data
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype.pause">module follow.Changes.prototype.pause</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.pause.pause">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype.resume">module follow.Changes.prototype.resume</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.resume.resume">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype.setEncoding">module follow.Changes.prototype.setEncoding</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.setEncoding.setEncoding">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setEncoding
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype.setHeader">module follow.Changes.prototype.setHeader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.setHeader.setHeader">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setHeader
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype.write">module follow.Changes.prototype.write</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.write.write">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype.write_continuous">module follow.Changes.prototype.write_continuous</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.write_continuous.write_continuous">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_continuous
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype.write_longpoll">module follow.Changes.prototype.write_longpoll</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.write_longpoll.write_longpoll">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_longpoll
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed">module follow.Feed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.Feed">
            function <span class="apidocSignatureSpan">follow.</span>Feed
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.super_">
            function <span class="apidocSignatureSpan">follow.Feed.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype">module follow.Feed.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.check_for_catchup">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>check_for_catchup
            <span class="apidocSignatureSpan">(seq)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.confirm">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>confirm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.die">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>die
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.follow">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>follow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.got_activity">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>got_activity
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_change">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_change
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_data">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_data
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_end">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_error">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_error
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_heartbeat">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_heartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_good_change">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_good_change
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_inactivity">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_inactivity
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_timeout">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_timeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.pause">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.prep">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>prep
            <span class="apidocSignatureSpan">(changes_stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.query">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>query
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.restart">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>restart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.resume">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.retry">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>retry
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.start">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.stop">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>stop
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.wait">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>wait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.check_for_catchup">module follow.Feed.prototype.check_for_catchup</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.check_for_catchup.check_for_catchup">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>check_for_catchup
            <span class="apidocSignatureSpan">(seq)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.confirm">module follow.Feed.prototype.confirm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.confirm.confirm">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>confirm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.die">module follow.Feed.prototype.die</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.die.die">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>die
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.follow">module follow.Feed.prototype.follow</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.follow.follow">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>follow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.got_activity">module follow.Feed.prototype.got_activity</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.got_activity.got_activity">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>got_activity
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.on_change">module follow.Feed.prototype.on_change</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_change.on_change">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_change
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.on_couch_data">module follow.Feed.prototype.on_couch_data</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_data.on_couch_data">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_data
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.on_couch_end">module follow.Feed.prototype.on_couch_end</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_end.on_couch_end">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.on_couch_error">module follow.Feed.prototype.on_couch_error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_error.on_couch_error">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_error
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.on_couch_heartbeat">module follow.Feed.prototype.on_couch_heartbeat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_heartbeat.on_couch_heartbeat">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_heartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.on_good_change">module follow.Feed.prototype.on_good_change</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_good_change.on_good_change">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_good_change
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.on_inactivity">module follow.Feed.prototype.on_inactivity</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_inactivity.on_inactivity">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_inactivity
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.on_timeout">module follow.Feed.prototype.on_timeout</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_timeout.on_timeout">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_timeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.pause">module follow.Feed.prototype.pause</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.pause.pause">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.prep">module follow.Feed.prototype.prep</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.prep.prep">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>prep
            <span class="apidocSignatureSpan">(changes_stream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.query">module follow.Feed.prototype.query</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.query.query">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>query
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.restart">module follow.Feed.prototype.restart</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.restart.restart">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>restart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.resume">module follow.Feed.prototype.resume</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.resume.resume">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.retry">module follow.Feed.prototype.retry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.retry.retry">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>retry
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.stop">module follow.Feed.prototype.stop</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.stop.stop">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>stop
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype.wait">module follow.Feed.prototype.wait</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.wait.wait">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>wait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.eventemitter2">module follow.eventemitter2</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.eventemitter2.EventEmitter2">
            function <span class="apidocSignatureSpan">follow.eventemitter2.</span>EventEmitter2
            <span class="apidocSignatureSpan">(conf)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.feed">module follow.feed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.feed.Feed">
            function <span class="apidocSignatureSpan">follow.feed.</span>Feed
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.stream">module follow.stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.stream.Changes">
            function <span class="apidocSignatureSpan">follow.stream.</span>Changes
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.toString">module follow.toString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.toString.toString">
            function <span class="apidocSignatureSpan">follow.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow" id="apidoc.module.follow">module follow</a></h1>


    <h2>
        <a href="#apidoc.element.follow.follow" id="apidoc.element.follow.follow">
        function <span class="apidocSignatureSpan"></span>follow
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function follow_feed(opts, cb) {
  var ch_feed = new feed.Feed(opts);
  ch_feed.on('error' , function(er) { return cb &amp;&amp; cb.call(ch_feed, er) });
  ch_feed.on('change', function(ch) { return cb &amp;&amp; cb.call(ch_feed, null, ch) });

  // Give the caller a chance to hook into any events.
  process.nextTick(function() {
    ch_feed.follow();
  })

  return ch_feed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})

feed.on('error', function(er) {
  console.error('Since Follow always retries on errors, this must be serious');
  throw er;
})

feed.<span class="apidocCodeKeywordSpan">follow</span>();
```

&lt;a name="pause"&gt;&lt;/a&gt;
## Pause and Resume

A Follow feed is a Node.js stream. If you get lots of changes and processing them takes a while, use `.pause()` and `.resume()`
as needed. Pausing guarantees that no new events will fire. Resuming guarantees you'll pick up where you left off.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes" id="apidoc.element.follow.Changes">
        function <span class="apidocSignatureSpan">follow.</span>Changes
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Changes(opts) {
  var self = this
  stream.call(self)

  self.readable = true
  self.writable = true

  self.headers = {}
  self.statusCode = null

  opts = opts || {}
  self.feed = opts.feed || null // "continuous" or "longpoll"
  self.encoding = opts.encoding || 'utf8'

  self.log = opts.log
  if(!self.log) {
    self.log = lib.log4js.getLogger('change_stream')
    self.log.setLevel(DEFS.log_level)
  }

  self.is_sending = true
  self.is_ending = false
  self.is_dead = false

  self.source = null
  self.expect = null
  self.buf = null
  self.changes = []

  self.on('pipe', function(src) {
    if(!self.source)
      self.source = src
    else {
      var er = new Error('Already have a pipe source')
      er.source = self.source
      self.error(er)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.destroy" id="apidoc.element.follow.Changes.prototype.destroy">
        function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Changes.prototype.destroy = function () {
  var self = this
  self.log.debug('destroy')

  self.is_dead = true
  self.is_ending = false
  self.is_sending = false

  if(self.source &amp;&amp; typeof self.source.abort == 'function')
    return self.source.abort()

  if(self.source &amp;&amp; typeof self.source.destroy === 'function')
    self.source.destroy()

  // Often the source is from the request package, so destroy its response object.
  if(self.source &amp;&amp; self.source.__isRequestRequest &amp;&amp; self.source.response
  &amp;&amp; typeof self.source.response.destroy === 'function')
    self.source.response.destroy()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.destroySoon" id="apidoc.element.follow.Changes.prototype.destroySoon">
        function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.destroySoon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Changes.prototype.destroySoon = function () {
  var self = this
  throw new Error('not implemented')
  //return self.request.destroySoon()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.emit_changes" id="apidoc.element.follow.Changes.prototype.emit_changes">
        function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.emit_changes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Changes.prototype.emit_changes = function () {
  var self = this

  while(self.is_sending &amp;&amp; self.changes.length &gt; 0) {
    var change = self.changes.shift()
    if(change === "") {
      self.log.debug('emit: heartbeat')
      self.emit('heartbeat')
    }

    else {
      self.log.debug('emit: data')
      self.emit('data', change)
    }
  }

  if(self.is_sending &amp;&amp; self.is_ending &amp;&amp; self.changes.length === 0) {
    self.is_ending = false
    self.readable = false
    self.log.debug('emit: end')
    self.emit('end')
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.end" id="apidoc.element.follow.Changes.prototype.end">
        function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.end
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Changes.prototype.end = function (data, encoding) {
  var self = this

  self.is_ending = true
  self.writable = false

  // Always call write, even with no data, so it can fire the "end" event.
  self.write(data, encoding)

  if(self.feed === 'longpoll') {
    var changes = [ DEFS.longpoll_header ].concat(self.buf).join('')
    try { changes = JSON.parse(changes) || {} }
    catch (er) { return self.error(er) }

    if(!Array.isArray(changes.results))
      return self.error(new Error('No "results" field in feed'))
    if(self.changes.length !== 0)
      return self.error(new Error('Changes are already queued: ' + JSON.stringify(self.changes)))

    self.changes = changes.results.map(function(change) { return JSON.stringify(change) })
    return self.emit_changes()
  }

  else if(self.feed === 'continuous') {
    if(self.buf !== "")
      self.log.debug('Unprocessed data after "end" called: ' + util.inspect(self.buf))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.error" id="apidoc.element.follow.Changes.prototype.error">
        function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.error
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Changes.prototype.error = function (er) {
  var self = this

  self.readable = false
  self.writable = false
  self.emit('error', er)

  // The write() method sometimes returns this value, so if there was an error, make write() return false.
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.normalize_data" id="apidoc.element.follow.Changes.prototype.normalize_data">
        function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.normalize_data
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Changes.prototype.normalize_data = function (data, encoding) {
  var self = this

  if(data instanceof Buffer)
    data = data.toString(encoding)
  else if(typeof data === 'undefined' &amp;&amp; typeof encoding === 'undefined')
    data = ""

  if(typeof data != 'string')
    return self.error(new Error('Not a string or Buffer: ' + util.inspect(data)))

  if(self.feed !== 'continuous' &amp;&amp; self.feed !== 'longpoll')
    return self.error(new Error('Must set .feed to "continuous" or "longpoll" before writing data'))

  if(self.expect === null)
    self.expect = (self.feed == 'longpoll')
                    ? DEFS.longpoll_header
                    : ""

  var prefix = data.substr(0, self.expect.length)
  data = data.substr(prefix.length)

  var expected_part = self.expect.substr(0, prefix.length)
    , expected_remainder = self.expect.substr(expected_part.length)

  if(prefix !== expected_part)
    return self.error(new Error('Prefix not expected '+util.inspect(expected_part)+': ' + util.inspect(prefix)))

  self.expect = expected_remainder
  return data
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.pause" id="apidoc.element.follow.Changes.prototype.pause">
        function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Changes.prototype.pause = function () {
  var self = this
  self.is_sending = false

  if(self.source &amp;&amp; self.source.pause)
    self.source.pause()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.resume" id="apidoc.element.follow.Changes.prototype.resume">
        function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Changes.prototype.resume = function () {
  var self = this
  self.is_sending = true
  if(self.source &amp;&amp; self.source.resume)
    self.source.resume()
  self.emit_changes()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.setEncoding" id="apidoc.element.follow.Changes.prototype.setEncoding">
        function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.setEncoding
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Changes.prototype.setEncoding = function (encoding) {
  var self = this
  self.encoding = encoding // TODO
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.setHeader" id="apidoc.element.follow.Changes.prototype.setHeader">
        function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.setHeader
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Changes.prototype.setHeader = function (key, val) {
  var self = this
  self.headers[key] = val
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.write" id="apidoc.element.follow.Changes.prototype.write">
        function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.write
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Changes.prototype.write = function (data, encoding) {
  var self = this

  data = self.normalize_data(data, encoding)
  if(typeof data != 'string')
    return // Looks like normalize_data emitted an error.

  if(self.feed === 'longpoll')
    return self.write_longpoll(data)
  else if(self.feed === 'continuous')
    return self.write_continuous(data)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.write_continuous" id="apidoc.element.follow.Changes.prototype.write_continuous">
        function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.write_continuous
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Changes.prototype.write_continuous = function (data) {
  var self = this

  var offset, json, change
    , buf = (self.buf || "") + data

  self.log.debug('write: ' + util.inspect({'data':data, 'buf':buf}))

  // Buf could have 0, 1, or many JSON objects in it.
  while((offset = buf.indexOf("\n")) &gt;= 0) {
    json = buf.substr(0, offset);
    buf = buf.substr(offset + 1);
    self.log.debug('JSON: ' + util.inspect(json))

    // Heartbeats (empty strings) are fine, but otherwise confirm valid JSON.
    if(json === "")
      ;

    else if(json[0] !== '{')
      return self.error(new Error('Non-object JSON data: ' + json))

    else {
      try { change = JSON.parse(json) }
      catch (er) { return self.error(er) }

      self.log.debug('Object: ' + util.inspect(change))
      json = JSON.stringify(change)
    }

    // Change (or heartbeat) looks good.
    self.changes.push(json)
  }

  // Remember the unused data and send all known good changes (or heartbeats). The data (or heartbeat)
  // event listeners may call .pause() so remember the is_sending state now before calling them.
  var was_sending = self.is_sending
  self.buf = buf
  self.emit_changes()
  return was_sending
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.write_longpoll" id="apidoc.element.follow.Changes.prototype.write_longpoll">
        function <span class="apidocSignatureSpan">follow.</span>Changes.prototype.write_longpoll
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Changes.prototype.write_longpoll = function (data) {
  var self = this

  if(self.buf === null)
    self.buf = []

  self.buf.push(data)
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed" id="apidoc.element.follow.Feed">
        function <span class="apidocSignatureSpan">follow.</span>Feed
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Feed(opts) {
  var self = this;
  EventEmitter.call(self);

  opts = opts || {}

  self.feed = 'continuous';
  self.heartbeat         = opts.heartbeat || DEFAULT_HEARTBEAT;
  self.max_retry_seconds = opts.max_retry_seconds || DEFAULT_MAX_RETRY_SECONDS;
  self.inactivity_ms = null;
  self.initial_retry_delay = opts.initial_retry_delay || INITIAL_RETRY_DELAY;
  self.response_grace_time = opts.response_grace_time || RESPONSE_GRACE_TIME;

  self.headers = {};
  self.request = opts.request || {} // Extra options for potentially future versions of request. The caller can supply them.

  self.since = 0;
  self.is_paused = false
  self.caught_up = false
  self.retry_delay = self.initial_retry_delay;

  self.query_params = {}; // Extra `req.query` values for filter functions

  if(typeof opts === 'string')
    opts = {'db': opts};

  Object.keys(opts).forEach(function(key) {
    if (typeof self[key] !== 'function')
      self[key] = opts[key];
  })

  self.pending = { request     : null
                 , activity_at : null
                 };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The main API is a thin wrapper around the EventEmitter API.

```javascript
var follow = require('follow');

var opts = {}; // Same options paramters as before
var feed = new follow.<span class="apidocCodeKeywordSpan">Feed</span>(opts);

// You can also set values directly.
feed.db            = "http://example.iriscouch.com/boogie";
feed.since         = 3;
feed.heartbeat     = 30    * 1000
feed.inactivity_ms = 86400 * 1000;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.check_for_catchup" id="apidoc.element.follow.Feed.prototype.check_for_catchup">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.check_for_catchup
        <span class="apidocSignatureSpan">(seq)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function check_for_catchup(seq) {
  var self = this

  if (self.is_db_updates)
    return
  if(self.caught_up)
    return
  if(seq &lt; self.original_db_seq)
    return

  self.caught_up = true
  self.emit('catchup', seq)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.confirm" id="apidoc.element.follow.Feed.prototype.confirm">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.confirm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function confirm_feed() {
  var self = this;

  self.db_safe = lib.scrub_creds(self.db);

  var endpoint = self.is_db_updates ? 'server' : 'database';

  self.log.debug('Checking ' + endpoint + ': ' + self.db_safe);

  var confirm_timeout = self.heartbeat * 3; // Give it time to look up the name, connect, etc.
  var timeout_id = setTimeout(function() {
    return self.die(new Error('Timeout confirming ' + endpoint + ': ' + self.db_safe));
  }, confirm_timeout);

  var headers = lib.JP(lib.JS(self.headers));
  headers.accept = 'application/json';

  var uri = self.is_db_updates ? self.db.replace(/\/_db_updates$/, '') : self.db;
  var req = {'uri':uri, 'headers':headers}
  Object.keys(self.request).forEach(function(key) {
    req[key] = self.request[key];
  })

  req = request(req, db_response)
  self.emit('confirm_request', req)

  function db_response(er, resp, body) {
    clearTimeout(timeout_id);

    if(er)
      return self.die(er);

    var db;
    try {
      db = JSON.parse(body)
    } catch(json_er) {
      return self.emit('error', json_er)
    }

    if(!self.is_db_updates &amp;&amp; !self.dead &amp;&amp; (!db.db_name || !db.instance_start_time))
      return self.emit('error', new Error('Bad DB response: ' + body));

    if(self.is_db_updates &amp;&amp; !self.dead &amp;&amp; !db.couchdb)
      return self.emit('error', new Error('Bad server response: ' + body));

    if (!self.is_db_updates)
      self.original_db_seq = db.update_seq

    self.log.debug('Confirmed ' + endpoint + ': ' + self.db_safe);
    self.emit('confirm', db);

    if(self.since == 'now') {
      self.log.debug('Query since "now" is the same as query since -1')
      self.since = -1
    }

    if(self.since == -1) {
      self.log.debug('Query since '+self.since+' will start at ' + db.update_seq)
      self.since = db.update_seq
    } else if(self.since &lt; 0) {
      if(isNaN(db.update_seq))
        return self.emit('error', new Error('DB requires specific id in "since"'));

      self.log.debug('Query since '+self.since+' will start at ' + (db.update_seq + self.since + 1))
      self.since = db.update_seq + self.since + 1
    }

    // If the next change would come after the current update_seq, just fake a catchup event now.
    if(self.original_db_seq == self.since) {
      self.caught_up = true
      self.emit('catchup', db.update_seq)
    }

    return self.query();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.die" id="apidoc.element.follow.Feed.prototype.die">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.die
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Feed.prototype.die = function (er) {
  var self = this;

  if(er)
    self.log.fatal('Fatal error: ' + er.stack);

  // Warn code executing later that death has occured.
  self.dead = true

  clearTimeout(self.retry_timer)
  clearTimeout(self.inactivity_timer)
  clearTimeout(self.pending.wait_timer)

  self.inactivity_timer = null
  self.pending.wait_timer = null

  var req = self.pending.request;
  self.pending.request = null;
  if(req) {
    self.log.debug('Destroying req ' + req.id());
    destroy_req(req);
  }

  if(er)
    self.emit('error', er);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.follow" id="apidoc.element.follow.Feed.prototype.follow">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.follow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function follow_feed() {
  var self = this;

  self.db = self.db || self.url || self.uri
  delete self.url
  delete self.uri

  if(!self.db)
    throw new Error('Database URL required');

  if (self.db.match(/\/_db_updates$/))
    self.is_db_updates = true;

  if(self.is_db_updates)
    delete self.since;

  if(self.feed !== 'continuous' &amp;&amp; self.feed !== 'longpoll')
    throw new Error('The only valid feed options are "continuous" and "longpoll"');

  if(typeof self.heartbeat !== 'number')
    throw new Error('Required "heartbeat" value');

  self.log = lib.log4js.getLogger(self.db);
  self.log.setLevel(process.env.follow_log_level || "info");

  self.emit('start');
  return self.confirm();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.got_activity" id="apidoc.element.follow.Feed.prototype.got_activity">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.got_activity
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Feed.prototype.got_activity = function () {
  var self = this

  if (self.dead)
    return

  //
  // We may not have a wait_timer so just clear it and null it out if it does
  // exist
  //
  clearTimeout(self.pending.wait_timer)
  self.pending.wait_timer = null
  self.pending.activity_at = new Date
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_change" id="apidoc.element.follow.Feed.prototype.on_change">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_change
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_change(change) {
  var self = this;

  if(!self.is_db_updates &amp;&amp; !change.seq)
    return self.die(new Error('No seq value in change: ' + lib.JS(change)));

  if(!self.is_db_updates &amp;&amp; change.seq == self.since) {
    self.log.debug('Bad seq value ' + change.seq + ' since=' + self.since);
    return destroy_req(self.pending.request);
  }

  if(typeof self.filter !== 'function')
    return self.on_good_change(change);

  var req = lib.JDUP({'query': self.pending.request.changes_query});
  var filter_args;

  if (self.is_db_updates) {
    if(!change.db_name || !change.type)
      return self.die(new Error('Internal _db_updates filter needs .db_name and .type in change ', change));
    filter_args = [change.db_name, change.type, req];
  } else {
    if(!change.doc)
      return self.die(new Error('Internal filter needs .doc in change ' + change.seq));

    // Don't let the filter mutate the real data.
    var doc = lib.JDUP(change.doc);
    filter_args = [doc, req];
  }
  var result = false;
  try {
    result = self.filter.apply(null, filter_args);
  } catch (er) {
    self.log.debug('Filter error', er);
  }

  result = (result &amp;&amp; true) || false;
  if(result) {
    self.log.debug('Builtin filter PASS for change: ' + change.seq);
    return self.on_good_change(change);
  } else {
    self.log.debug('Builtin filter FAIL for change: ' + change.seq);

    // Even with a filtered change, a "catchup" event might still be appropriate.
    self.check_for_catchup(change.seq)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_data" id="apidoc.element.follow.Feed.prototype.on_couch_data">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_couch_data
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_data(change) {
  var self = this;
  self.log.debug('Data from ' + self.pending.request.id());

  self.got_activity()
  if(self.dead)
    return self.log.debug('Skip data processing for dead feed')

  // The changes stream guarantees that this data is valid JSON.
  change = JSON.parse(change)

  //self.log.debug('Object:\n' + util.inspect(change));
  if(!self.is_db_updates &amp;&amp; 'last_seq' in change) {
    self.log.warn('Stopping upon receiving a final message: ' + JSON.stringify(change))
    var del_er = new Error('Database deleted after change: ' + change.last_seq)
    del_er.deleted = true
    del_er.last_seq = change.last_seq
    return self.die(del_er)
  }

  if(!self.is_db_updates &amp;&amp; !change.seq)
    return self.die(new Error('Change has no .seq field: ' + JSON.stringify(change)))

  self.on_change(change)

  // on_change() might work its way all the way to a "change" event, and the listener
  // might call .stop(), which means among other things that no more events are desired.
  // The die() code sets a self.dead flag to indicate this.
  if(self.dead)
    return self.log.debug('No wait: change listener stopped this feed')
  self.wait()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_end" id="apidoc.element.follow.Feed.prototype.on_couch_end">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_couch_end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_end() {
  var self = this;

  self.log.debug('Changes feed ended ' + self.pending.request.id());
  self.pending.request = null;
  return self.retry();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_error" id="apidoc.element.follow.Feed.prototype.on_couch_error">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_couch_error
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_error(er) {
  var self = this;

  self.log.debug('Changes query eror: ' + lib.JS(er.stack));
  return self.retry();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_heartbeat" id="apidoc.element.follow.Feed.prototype.on_couch_heartbeat">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_couch_heartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_heartbeat() {
  var self = this

  self.got_activity()
  if(self.dead)
    return self.log.debug('Skip heartbeat processing for dead feed')

  self.emit('heartbeat')

  if(self.dead)
    return self.log.debug('No wait: heartbeat listener stopped this feed')
  self.wait()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_good_change" id="apidoc.element.follow.Feed.prototype.on_good_change">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_good_change
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_good_change(change) {
  var self = this;

  if(self.inactivity_ms &amp;&amp; !self.inactivity_timer)
    return self.die(new Error('Cannot find inactivity timer during change'));

  clearTimeout(self.inactivity_timer);
  self.inactivity_timer = null;
  if(self.inactivity_ms)
    self.inactivity_timer = setTimeout(function() { self.on_inactivity() }, self.inactivity_ms);

  self.change_at = new Date;

  if(!self.is_db_updates)
    self.since = change.seq;

  self.emit('change', change);

  self.check_for_catchup(change.seq)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_inactivity" id="apidoc.element.follow.Feed.prototype.on_inactivity">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_inactivity
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_inactivity() {
  var self = this;
  var now = new Date;
  var elapsed_ms = now - self.change_at;
  var elapsed_s  = elapsed_ms / 1000;

  //
  // Since this is actually not fatal, lets just totally reset and start a new
  // request, JUST in case something was bad.
  //
  self.log.debug('Req ' + self.pending.request.id() + ' made no changes for ' + elapsed_s + 's');
  return self.restart();

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_timeout" id="apidoc.element.follow.Feed.prototype.on_timeout">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.on_timeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_timeout() {
  var self = this;
  if (self.dead)
    return self.log.debug('No timeout: change listener stopped this feed');

  self.log.debug('Timeout')

  var now = new Date;
  var elapsed_ms = now - self.pending.activity_at;

  self.emit('timeout', {elapsed_ms:elapsed_ms, heartbeat:self.heartbeat, id:self.pending.request.id()});

<span class="apidocCodeCommentSpan">  /*
  var msg = ' for timeout after ' + elapsed_ms + 'ms; heartbeat=' + self.heartbeat;
  if(!self.pending.request.id)
    self.log.warn('Closing req (no id) ' + msg + ' req=' + util.inspect(self.pending.request));
  else
    self.log.warn('Closing req ' + self.pending.request.id() + msg);
  */
</span>
  destroy_req(self.pending.request);
  self.retry()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.pause" id="apidoc.element.follow.Feed.prototype.pause">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Feed.prototype.pause = function () {
  var self = this
    , was_paused = self.is_paused

  // Emit pause after pausing the stream, to allow listeners to react.
  self.is_paused = true
  if(self.pending &amp;&amp; self.pending.request &amp;&amp; self.pending.request.pause)
    self.pending.request.pause()
  else
    self.log.warn('No pending request to pause')

  if(!was_paused)
    self.emit('pause')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.prep" id="apidoc.element.follow.Feed.prototype.prep">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.prep
        <span class="apidocSignatureSpan">(changes_stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prep_request(changes_stream) {
  var self = this;

  var now = new Date;
  self.pending.request = changes_stream;
  self.pending.activity_at = now;
  self.pending.wait_timer  = null;

  // Just re-run the pause or resume to do the needful on changes_stream (self.pending.request).
  if(self.is_paused)
    self.pause()
  else
    self.resume()

  // The inactivity timer is for time between *changes*, or time between the
  // initial connection and the first change. Therefore it goes here.
  self.change_at = now;
  if(self.inactivity_ms) {
    clearTimeout(self.inactivity_timer);
    self.inactivity_timer = setTimeout(function() { self.on_inactivity() }, self.inactivity_ms);
  }

  changes_stream.on('heartbeat', handler_for('heartbeat'))
  changes_stream.on('error', handler_for('error'))
  changes_stream.on('data', handler_for('data'))
  changes_stream.on('end', handler_for('end'))

  return self.wait();

  function handler_for(ev) {
    var name = 'on_couch_' + ev;
    var inner_handler = self[name];

    return handle_confirmed_req_event;
    function handle_confirmed_req_event() {
      if(self.pending.request === changes_stream)
        return inner_handler.apply(self, arguments);

      if(!changes_stream.created_at)
        return self.die(new Error("Received data from unknown request")); // Pretty sure this is impossible.

      var s_to_now = (new Date() - changes_stream.created_at) / 1000;
      var s_to_req = '[no req]';
      if(self.pending.request)
        s_to_req = (self.pending.request.created_at - changes_stream.created_at) / 1000;

      var msg = ': ' + changes_stream.id() + ' to_req=' + s_to_req + 's, to_now=' + s_to_now + 's';

      if(ev == 'end' || ev == 'data' || ev == 'heartbeat') {
        self.log.debug('Old "' + ev + '": ' + changes_stream.id())
        return destroy_req(changes_stream)
      }

      self.log.warn('Old "'+ev+'"' + msg);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.query" id="apidoc.element.follow.Feed.prototype.query">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.query
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query_feed() {
  var self = this;

  var query_params = JSON.parse(JSON.stringify(self.query_params));

  FEED_PARAMETERS.forEach(function(key) {
    if(key in self)
      query_params[key] = self[key];
  })

  if(typeof query_params.filter !== 'string')
    delete query_params.filter;

  if(typeof self.filter === 'function' &amp;&amp; !query_params.include_docs) {
    self.log.debug('Enabling include_docs for client-side filter');
    query_params.include_docs = true;
  }

  // Limit the response size for longpoll.
  var poll_size = 100;
  if(query_params.feed == 'longpoll' &amp;&amp; (!query_params.limit || query_params.limit &gt; poll_size))
    query_params.limit = poll_size;

  var feed_url = self.db + (self.is_db_updates ? '' : '/_changes') + '?' + querystring.stringify(query_params);

  self.headers.accept = self.headers.accept || 'application/json';
  var req = { method : 'GET'
            , uri    : feed_url
            , headers: self.headers
            , encoding: 'utf-8'
            }

  req.changes_query = query_params;
  Object.keys(self.request).forEach(function(key) {
    req[key] = self.request[key];
  })

  var now = new Date
    , feed_ts = lib.JDUP(now)
    , feed_id = process.env.follow_debug ? feed_ts.match(/\.(\d\d\d)Z$/)[1] : feed_ts

  self.log.debug('Feed query ' + feed_id + ': ' + lib.scrub_creds(feed_url))
  var feed_request = request(req)

  feed_request.on('response', function(res) {
    self.log.debug('Remove feed from agent pool: ' + feed_id)
    feed_request.req.socket.emit('agentRemove')

    // Simulate the old onResponse option.
    on_feed_response(null, res, res.body)
  })

  feed_request.on('error', on_feed_response)

  // The response headers must arrive within one heartbeat.
  var response_timer = setTimeout(response_timed_out, self.heartbeat + self.response_grace_time)
    , timed_out = false

  return self.emit('query', feed_request)

  function response_timed_out() {
    self.log.debug('Feed response timed out: ' + feed_id)
    timed_out = true
    return self.retry()
  }

  function on_feed_response(er, resp, body) {
    clearTimeout(response_timer)

    if((resp !== undefined &amp;&amp; resp.body) || body)
      return self.die(new Error('Cannot handle a body in the feed response: ' + lib.JS(resp.body || body)))

    if(timed_out) {
      self.log.debug('Ignoring late response: ' + feed_id);
      return destroy_response(resp);
    }

    if(er) {
      self.log.debug('Request error ' + feed_id + ': ' + er.stack);
      destroy_response(resp);
      return self.retry();
    }

    if(resp.statusCode !== 200) {
      self.log.debug('Bad changes response ' + feed_id + ': ' + resp.statusCode);
      destroy_response(resp);
      return self.retry();
    }

    self.log.debug('Good response: ' + feed_id);
    self.retry_delay = self.initial_retry_delay;

    self.emit('response', resp);

    var changes_stream = new Changes
    changes_stream.log = lib.log4js.getLogger('stream ' + self.db)
    changes_stream.log.setLevel(self.log.level.levelStr)
    changes_stream.feed = self.feed
    feed_request.pipe(changes_stream)

    changes_stream.created_at = now
    changes_stream.id = function() { return feed_id }
    return self.prep(changes_stream)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.restart" id="apidoc.element.follow.Feed.prototype.restart">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.restart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function restart() {
  var self = this

  self.emit('restart')

  // Kill ourselves and then start up once again
  self.stop()
  self.dead = false
  self.start()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.resume" id="apidoc.element.follow.Feed.prototype.resume">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Feed.prototype.resume = function () {
  var self = this
    , was_paused = self.is_paused

  // Emit resume before resuming the data feed, to allow listeners to prepare.
  self.is_paused = false
  if(was_paused)
    self.emit('resume')

  if(self.pending &amp;&amp; self.pending.request &amp;&amp; self.pending.request.resume)
    self.pending.request.resume()
  else
    self.log.warn('No pending request to resume')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.retry" id="apidoc.element.follow.Feed.prototype.retry">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.retry
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry() {
  var self = this;

  clearTimeout(self.pending.wait_timer);
  self.pending.wait_timer = null;

  self.log.debug('Retry since=' + self.since + ' after ' + self.retry_delay + 'ms ')
  self.emit('retry', {since:self.since, after:self.retry_delay, db:self.db_safe});

  self.retry_timer = setTimeout(function() { self.query() }, self.retry_delay);

  var max_retry_ms = self.max_retry_seconds * 1000;
  self.retry_delay *= 2;
  if(self.retry_delay &gt; max_retry_ms)
    self.retry_delay = max_retry_ms;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.stop" id="apidoc.element.follow.Feed.prototype.stop">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.stop
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Feed.prototype.stop = function (val) {
  var self = this
  self.log.debug('Stop')

  // Die with no errors.
  self.die()
  self.emit('stop', val);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.wait" id="apidoc.element.follow.Feed.prototype.wait">
        function <span class="apidocSignatureSpan">follow.</span>Feed.prototype.wait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wait_for_event() {
  var self = this;
  self.emit('wait');

  if(self.pending.wait_timer)
    return self.die(new Error('wait() called but there is already a wait_timer: ' + self.pending.wait_timer));

  var timeout_ms = self.heartbeat * HEARTBEAT_TIMEOUT_COEFFICIENT;
  var req_id = self.pending.request &amp;&amp; self.pending.request.id()
  var msg = 'Req ' + req_id + ' timeout=' + timeout_ms;
  if(self.inactivity_ms)
    msg += ', inactivity=' + self.inactivity_ms;
  msg += ': ' + self.db_safe;

  self.log.debug(msg);
  self.pending.wait_timer = setTimeout(function() { self.on_timeout() }, timeout_ms);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.api" id="apidoc.element.follow.api">
        function <span class="apidocSignatureSpan">follow.</span>api
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function follow_feed(opts, cb) {
  var ch_feed = new feed.Feed(opts);
  ch_feed.on('error' , function(er) { return cb &amp;&amp; cb.call(ch_feed, er) });
  ch_feed.on('change', function(ch) { return cb &amp;&amp; cb.call(ch_feed, null, ch) });

  // Give the caller a chance to hook into any events.
  process.nextTick(function() {
    ch_feed.follow();
  })

  return ch_feed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.toString" id="apidoc.element.follow.toString">
        function <span class="apidocSignatureSpan">follow.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function install(filename, target, callback) {
  //console.log('Exporting: ' + filename);
  fs.readFile(filename, null, function(er, content) {
if(er &amp;&amp; er.errno) er = new Error(er.stack); // Make a better stack trace.
if(er) return callback(er);

// Strip the shebang.
content = content.<span class="apidocCodeKeywordSpan">toString</span>('utf8');
var content_lines = content.split(/\n/);
content_lines[0] = content_lines[0].replace(/^(#!.*)$/, '// $1');

// TODO
// content_lines.join('\n'), maybe new Buffer of that

//Convert the Node module (CommonJS) to RequireJS.
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes" id="apidoc.module.follow.Changes">module follow.Changes</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.Changes" id="apidoc.element.follow.Changes.Changes">
        function <span class="apidocSignatureSpan">follow.</span>Changes
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Changes(opts) {
  var self = this
  stream.call(self)

  self.readable = true
  self.writable = true

  self.headers = {}
  self.statusCode = null

  opts = opts || {}
  self.feed = opts.feed || null // "continuous" or "longpoll"
  self.encoding = opts.encoding || 'utf8'

  self.log = opts.log
  if(!self.log) {
    self.log = lib.log4js.getLogger('change_stream')
    self.log.setLevel(DEFS.log_level)
  }

  self.is_sending = true
  self.is_ending = false
  self.is_dead = false

  self.source = null
  self.expect = null
  self.buf = null
  self.changes = []

  self.on('pipe', function(src) {
    if(!self.source)
      self.source = src
    else {
      var er = new Error('Already have a pipe source')
      er.source = self.source
      self.error(er)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.super_" id="apidoc.element.follow.Changes.super_">
        function <span class="apidocSignatureSpan">follow.Changes.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype" id="apidoc.module.follow.Changes.prototype">module follow.Changes.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.destroy" id="apidoc.element.follow.Changes.prototype.destroy">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  var self = this
  self.log.debug('destroy')

  self.is_dead = true
  self.is_ending = false
  self.is_sending = false

  if(self.source &amp;&amp; typeof self.source.abort == 'function')
    return self.source.abort()

  if(self.source &amp;&amp; typeof self.source.destroy === 'function')
    self.source.destroy()

  // Often the source is from the request package, so destroy its response object.
  if(self.source &amp;&amp; self.source.__isRequestRequest &amp;&amp; self.source.response
  &amp;&amp; typeof self.source.response.destroy === 'function')
    self.source.response.destroy()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

function destroy_req(req) {
if(req)
  destroy_response(req.response)

if(req &amp;&amp; typeof req.destroy == 'function')
  req.<span class="apidocCodeKeywordSpan">destroy</span>()
}

function destroy_response(response) {
if(!response)
  return;

if(typeof response.abort === 'function')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.destroySoon" id="apidoc.element.follow.Changes.prototype.destroySoon">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroySoon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroySoon = function () {
  var self = this
  throw new Error('not implemented')
  //return self.request.destroySoon()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self.source.response.destroy()
}


Changes.prototype.destroySoon = function() {
  var self = this
  throw new Error('not implemented')
  //return self.request.<span class="apidocCodeKeywordSpan">destroySoon</span>()
}

//
// Internal implementation
//

Changes.prototype.normalize_data = function(data, encoding) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.emit_changes" id="apidoc.element.follow.Changes.prototype.emit_changes">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>emit_changes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit_changes = function () {
  var self = this

  while(self.is_sending &amp;&amp; self.changes.length &gt; 0) {
    var change = self.changes.shift()
    if(change === "") {
      self.log.debug('emit: heartbeat')
      self.emit('heartbeat')
    }

    else {
      self.log.debug('emit: data')
      self.emit('data', change)
    }
  }

  if(self.is_sending &amp;&amp; self.is_ending &amp;&amp; self.changes.length === 0) {
    self.is_ending = false
    self.readable = false
    self.log.debug('emit: end')
    self.emit('end')
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


Changes.prototype.resume = function() {
  var self = this
  self.is_sending = true
  if(self.source &amp;&amp; self.source.resume)
    self.source.resume()
  self.<span class="apidocCodeKeywordSpan">emit_changes</span>()
}

//
// Writable stream API
//

Changes.prototype.write = function(data, encoding) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.end" id="apidoc.element.follow.Changes.prototype.end">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>end
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (data, encoding) {
  var self = this

  self.is_ending = true
  self.writable = false

  // Always call write, even with no data, so it can fire the "end" event.
  self.write(data, encoding)

  if(self.feed === 'longpoll') {
    var changes = [ DEFS.longpoll_header ].concat(self.buf).join('')
    try { changes = JSON.parse(changes) || {} }
    catch (er) { return self.error(er) }

    if(!Array.isArray(changes.results))
      return self.error(new Error('No "results" field in feed'))
    if(self.changes.length !== 0)
      return self.error(new Error('Changes are already queued: ' + JSON.stringify(self.changes)))

    self.changes = changes.results.map(function(change) { return JSON.stringify(change) })
    return self.emit_changes()
  }

  else if(self.feed === 'continuous') {
    if(self.buf !== "")
      self.log.debug('Unprocessed data after "end" called: ' + util.inspect(self.buf))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.error" id="apidoc.element.follow.Changes.prototype.error">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>error
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (er) {
  var self = this

  self.readable = false
  self.writable = false
  self.emit('error', er)

  // The write() method sometimes returns this value, so if there was an error, make write() return false.
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

feed.on('change', function(change) {
  console.log('Doc ' + change.id + ' in change ' + change.seq + ' is neither stinky nor ugly.');
})

feed.on('error', function(er) {
  console.<span class="apidocCodeKeywordSpan">error</span>('Since Follow always retries on errors, this must be serious'
;);
  throw er;
})

feed.follow();
```

&lt;a name="pause"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.normalize_data" id="apidoc.element.follow.Changes.prototype.normalize_data">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>normalize_data
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalize_data = function (data, encoding) {
  var self = this

  if(data instanceof Buffer)
    data = data.toString(encoding)
  else if(typeof data === 'undefined' &amp;&amp; typeof encoding === 'undefined')
    data = ""

  if(typeof data != 'string')
    return self.error(new Error('Not a string or Buffer: ' + util.inspect(data)))

  if(self.feed !== 'continuous' &amp;&amp; self.feed !== 'longpoll')
    return self.error(new Error('Must set .feed to "continuous" or "longpoll" before writing data'))

  if(self.expect === null)
    self.expect = (self.feed == 'longpoll')
                    ? DEFS.longpoll_header
                    : ""

  var prefix = data.substr(0, self.expect.length)
  data = data.substr(prefix.length)

  var expected_part = self.expect.substr(0, prefix.length)
    , expected_remainder = self.expect.substr(expected_part.length)

  if(prefix !== expected_part)
    return self.error(new Error('Prefix not expected '+util.inspect(expected_part)+': ' + util.inspect(prefix)))

  self.expect = expected_remainder
  return data
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// Writable stream API
//

Changes.prototype.write = function(data, encoding) {
var self = this

data = self.<span class="apidocCodeKeywordSpan">normalize_data</span>(data, encoding)
if(typeof data != 'string')
  return // Looks like normalize_data emitted an error.

if(self.feed === 'longpoll')
  return self.write_longpoll(data)
else if(self.feed === 'continuous')
  return self.write_continuous(data)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.pause" id="apidoc.element.follow.Changes.prototype.pause">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  var self = this
  self.is_sending = false

  if(self.source &amp;&amp; self.source.pause)
    self.source.pause()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

feed.follow();
```

&lt;a name="pause"&gt;&lt;/a&gt;
## Pause and Resume

A Follow feed is a Node.js stream. If you get lots of changes and processing them takes a while, use `.<span class="apidocCodeKeywordSpan
">pause</span>()` and `.resume()` as needed. Pausing guarantees that no new events will fire. Resuming guarantees you'll pick
 up where you left off.

```javascript
follow("https://example.iriscouch.com/boogie", function(error, change) {
var feed = this

if(change.seq == 1) {
  console.log('Uh oh. The first change takes 30 hours to process. Better pause.')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.resume" id="apidoc.element.follow.Changes.prototype.resume">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  var self = this
  self.is_sending = true
  if(self.source &amp;&amp; self.source.resume)
    self.source.resume()
  self.emit_changes()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

feed.follow();
```

&lt;a name="pause"&gt;&lt;/a&gt;
## Pause and Resume

A Follow feed is a Node.js stream. If you get lots of changes and processing them takes a while, use `.pause()` and `.<span class="apidocCodeKeywordSpan">resume</span>()` as needed. Pausing guarantees that no new events will fire. Resuming guarantees you'
;ll pick up where you left off.

```javascript
follow("https://example.iriscouch.com/boogie", function(error, change) {
var feed = this

if(change.seq == 1) {
  console.log('Uh oh. The first change takes 30 hours to process. Better pause.')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.setEncoding" id="apidoc.element.follow.Changes.prototype.setEncoding">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setEncoding
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEncoding = function (encoding) {
  var self = this
  self.encoding = encoding // TODO
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.setHeader" id="apidoc.element.follow.Changes.prototype.setHeader">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setHeader
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setHeader = function (key, val) {
  var self = this
  self.headers[key] = val
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.write" id="apidoc.element.follow.Changes.prototype.write">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (data, encoding) {
  var self = this

  data = self.normalize_data(data, encoding)
  if(typeof data != 'string')
    return // Looks like normalize_data emitted an error.

  if(self.feed === 'longpoll')
    return self.write_longpoll(data)
  else if(self.feed === 'continuous')
    return self.write_continuous(data)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Changes.prototype.end = function(data, encoding) {
  var self = this

  self.is_ending = true
  self.writable = false

  // Always call write, even with no data, so it can fire the "end" event.
  self.<span class="apidocCodeKeywordSpan">write</span>(data, encoding)

  if(self.feed === 'longpoll') {
var changes = [ DEFS.longpoll_header ].concat(self.buf).join('')
try { changes = JSON.parse(changes) || {} }
catch (er) { return self.error(er) }

if(!Array.isArray(changes.results))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.write_continuous" id="apidoc.element.follow.Changes.prototype.write_continuous">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_continuous
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write_continuous = function (data) {
  var self = this

  var offset, json, change
    , buf = (self.buf || "") + data

  self.log.debug('write: ' + util.inspect({'data':data, 'buf':buf}))

  // Buf could have 0, 1, or many JSON objects in it.
  while((offset = buf.indexOf("\n")) &gt;= 0) {
    json = buf.substr(0, offset);
    buf = buf.substr(offset + 1);
    self.log.debug('JSON: ' + util.inspect(json))

    // Heartbeats (empty strings) are fine, but otherwise confirm valid JSON.
    if(json === "")
      ;

    else if(json[0] !== '{')
      return self.error(new Error('Non-object JSON data: ' + json))

    else {
      try { change = JSON.parse(json) }
      catch (er) { return self.error(er) }

      self.log.debug('Object: ' + util.inspect(change))
      json = JSON.stringify(change)
    }

    // Change (or heartbeat) looks good.
    self.changes.push(json)
  }

  // Remember the unused data and send all known good changes (or heartbeats). The data (or heartbeat)
  // event listeners may call .pause() so remember the is_sending state now before calling them.
  var was_sending = self.is_sending
  self.buf = buf
  self.emit_changes()
  return was_sending
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
data = self.normalize_data(data, encoding)
if(typeof data != 'string')
  return // Looks like normalize_data emitted an error.

if(self.feed === 'longpoll')
  return self.write_longpoll(data)
else if(self.feed === 'continuous')
  return self.<span class="apidocCodeKeywordSpan">write_continuous</span>(data)
}


Changes.prototype.write_longpoll = function(data) {
var self = this

if(self.buf === null)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.write_longpoll" id="apidoc.element.follow.Changes.prototype.write_longpoll">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_longpoll
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write_longpoll = function (data) {
  var self = this

  if(self.buf === null)
    self.buf = []

  self.buf.push(data)
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var self = this

data = self.normalize_data(data, encoding)
if(typeof data != 'string')
  return // Looks like normalize_data emitted an error.

if(self.feed === 'longpoll')
  return self.<span class="apidocCodeKeywordSpan">write_longpoll</span>(data)
else if(self.feed === 'continuous')
  return self.write_continuous(data)
}


Changes.prototype.write_longpoll = function(data) {
var self = this
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype.destroy" id="apidoc.module.follow.Changes.prototype.destroy">module follow.Changes.prototype.destroy</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.destroy.destroy" id="apidoc.element.follow.Changes.prototype.destroy.destroy">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  var self = this
  self.log.debug('destroy')

  self.is_dead = true
  self.is_ending = false
  self.is_sending = false

  if(self.source &amp;&amp; typeof self.source.abort == 'function')
    return self.source.abort()

  if(self.source &amp;&amp; typeof self.source.destroy === 'function')
    self.source.destroy()

  // Often the source is from the request package, so destroy its response object.
  if(self.source &amp;&amp; self.source.__isRequestRequest &amp;&amp; self.source.response
  &amp;&amp; typeof self.source.response.destroy === 'function')
    self.source.response.destroy()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

function destroy_req(req) {
if(req)
  destroy_response(req.response)

if(req &amp;&amp; typeof req.destroy == 'function')
  req.<span class="apidocCodeKeywordSpan">destroy</span>()
}

function destroy_response(response) {
if(!response)
  return;

if(typeof response.abort === 'function')
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype.destroySoon" id="apidoc.module.follow.Changes.prototype.destroySoon">module follow.Changes.prototype.destroySoon</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.destroySoon.destroySoon" id="apidoc.element.follow.Changes.prototype.destroySoon.destroySoon">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroySoon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroySoon = function () {
  var self = this
  throw new Error('not implemented')
  //return self.request.destroySoon()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self.source.response.destroy()
}


Changes.prototype.destroySoon = function() {
  var self = this
  throw new Error('not implemented')
  //return self.request.<span class="apidocCodeKeywordSpan">destroySoon</span>()
}

//
// Internal implementation
//

Changes.prototype.normalize_data = function(data, encoding) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype.emit_changes" id="apidoc.module.follow.Changes.prototype.emit_changes">module follow.Changes.prototype.emit_changes</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.emit_changes.emit_changes" id="apidoc.element.follow.Changes.prototype.emit_changes.emit_changes">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>emit_changes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit_changes = function () {
  var self = this

  while(self.is_sending &amp;&amp; self.changes.length &gt; 0) {
    var change = self.changes.shift()
    if(change === "") {
      self.log.debug('emit: heartbeat')
      self.emit('heartbeat')
    }

    else {
      self.log.debug('emit: data')
      self.emit('data', change)
    }
  }

  if(self.is_sending &amp;&amp; self.is_ending &amp;&amp; self.changes.length === 0) {
    self.is_ending = false
    self.readable = false
    self.log.debug('emit: end')
    self.emit('end')
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


Changes.prototype.resume = function() {
  var self = this
  self.is_sending = true
  if(self.source &amp;&amp; self.source.resume)
    self.source.resume()
  self.<span class="apidocCodeKeywordSpan">emit_changes</span>()
}

//
// Writable stream API
//

Changes.prototype.write = function(data, encoding) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype.end" id="apidoc.module.follow.Changes.prototype.end">module follow.Changes.prototype.end</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.end.end" id="apidoc.element.follow.Changes.prototype.end.end">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>end
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (data, encoding) {
  var self = this

  self.is_ending = true
  self.writable = false

  // Always call write, even with no data, so it can fire the "end" event.
  self.write(data, encoding)

  if(self.feed === 'longpoll') {
    var changes = [ DEFS.longpoll_header ].concat(self.buf).join('')
    try { changes = JSON.parse(changes) || {} }
    catch (er) { return self.error(er) }

    if(!Array.isArray(changes.results))
      return self.error(new Error('No "results" field in feed'))
    if(self.changes.length !== 0)
      return self.error(new Error('Changes are already queued: ' + JSON.stringify(self.changes)))

    self.changes = changes.results.map(function(change) { return JSON.stringify(change) })
    return self.emit_changes()
  }

  else if(self.feed === 'continuous') {
    if(self.buf !== "")
      self.log.debug('Unprocessed data after "end" called: ' + util.inspect(self.buf))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype.error" id="apidoc.module.follow.Changes.prototype.error">module follow.Changes.prototype.error</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.error.error" id="apidoc.element.follow.Changes.prototype.error.error">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>error
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (er) {
  var self = this

  self.readable = false
  self.writable = false
  self.emit('error', er)

  // The write() method sometimes returns this value, so if there was an error, make write() return false.
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

feed.on('change', function(change) {
  console.log('Doc ' + change.id + ' in change ' + change.seq + ' is neither stinky nor ugly.');
})

feed.on('error', function(er) {
  console.<span class="apidocCodeKeywordSpan">error</span>('Since Follow always retries on errors, this must be serious'
;);
  throw er;
})

feed.follow();
```

&lt;a name="pause"&gt;&lt;/a&gt;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype.normalize_data" id="apidoc.module.follow.Changes.prototype.normalize_data">module follow.Changes.prototype.normalize_data</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.normalize_data.normalize_data" id="apidoc.element.follow.Changes.prototype.normalize_data.normalize_data">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>normalize_data
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalize_data = function (data, encoding) {
  var self = this

  if(data instanceof Buffer)
    data = data.toString(encoding)
  else if(typeof data === 'undefined' &amp;&amp; typeof encoding === 'undefined')
    data = ""

  if(typeof data != 'string')
    return self.error(new Error('Not a string or Buffer: ' + util.inspect(data)))

  if(self.feed !== 'continuous' &amp;&amp; self.feed !== 'longpoll')
    return self.error(new Error('Must set .feed to "continuous" or "longpoll" before writing data'))

  if(self.expect === null)
    self.expect = (self.feed == 'longpoll')
                    ? DEFS.longpoll_header
                    : ""

  var prefix = data.substr(0, self.expect.length)
  data = data.substr(prefix.length)

  var expected_part = self.expect.substr(0, prefix.length)
    , expected_remainder = self.expect.substr(expected_part.length)

  if(prefix !== expected_part)
    return self.error(new Error('Prefix not expected '+util.inspect(expected_part)+': ' + util.inspect(prefix)))

  self.expect = expected_remainder
  return data
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// Writable stream API
//

Changes.prototype.write = function(data, encoding) {
var self = this

data = self.<span class="apidocCodeKeywordSpan">normalize_data</span>(data, encoding)
if(typeof data != 'string')
  return // Looks like normalize_data emitted an error.

if(self.feed === 'longpoll')
  return self.write_longpoll(data)
else if(self.feed === 'continuous')
  return self.write_continuous(data)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype.pause" id="apidoc.module.follow.Changes.prototype.pause">module follow.Changes.prototype.pause</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.pause.pause" id="apidoc.element.follow.Changes.prototype.pause.pause">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  var self = this
  self.is_sending = false

  if(self.source &amp;&amp; self.source.pause)
    self.source.pause()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

feed.follow();
```

&lt;a name="pause"&gt;&lt;/a&gt;
## Pause and Resume

A Follow feed is a Node.js stream. If you get lots of changes and processing them takes a while, use `.<span class="apidocCodeKeywordSpan
">pause</span>()` and `.resume()` as needed. Pausing guarantees that no new events will fire. Resuming guarantees you'll pick
 up where you left off.

```javascript
follow("https://example.iriscouch.com/boogie", function(error, change) {
var feed = this

if(change.seq == 1) {
  console.log('Uh oh. The first change takes 30 hours to process. Better pause.')
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype.resume" id="apidoc.module.follow.Changes.prototype.resume">module follow.Changes.prototype.resume</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.resume.resume" id="apidoc.element.follow.Changes.prototype.resume.resume">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  var self = this
  self.is_sending = true
  if(self.source &amp;&amp; self.source.resume)
    self.source.resume()
  self.emit_changes()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

feed.follow();
```

&lt;a name="pause"&gt;&lt;/a&gt;
## Pause and Resume

A Follow feed is a Node.js stream. If you get lots of changes and processing them takes a while, use `.pause()` and `.<span class="apidocCodeKeywordSpan">resume</span>()` as needed. Pausing guarantees that no new events will fire. Resuming guarantees you'
;ll pick up where you left off.

```javascript
follow("https://example.iriscouch.com/boogie", function(error, change) {
var feed = this

if(change.seq == 1) {
  console.log('Uh oh. The first change takes 30 hours to process. Better pause.')
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype.setEncoding" id="apidoc.module.follow.Changes.prototype.setEncoding">module follow.Changes.prototype.setEncoding</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.setEncoding.setEncoding" id="apidoc.element.follow.Changes.prototype.setEncoding.setEncoding">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setEncoding
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEncoding = function (encoding) {
  var self = this
  self.encoding = encoding // TODO
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype.setHeader" id="apidoc.module.follow.Changes.prototype.setHeader">module follow.Changes.prototype.setHeader</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.setHeader.setHeader" id="apidoc.element.follow.Changes.prototype.setHeader.setHeader">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setHeader
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setHeader = function (key, val) {
  var self = this
  self.headers[key] = val
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype.write" id="apidoc.module.follow.Changes.prototype.write">module follow.Changes.prototype.write</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.write.write" id="apidoc.element.follow.Changes.prototype.write.write">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (data, encoding) {
  var self = this

  data = self.normalize_data(data, encoding)
  if(typeof data != 'string')
    return // Looks like normalize_data emitted an error.

  if(self.feed === 'longpoll')
    return self.write_longpoll(data)
  else if(self.feed === 'continuous')
    return self.write_continuous(data)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Changes.prototype.end = function(data, encoding) {
  var self = this

  self.is_ending = true
  self.writable = false

  // Always call write, even with no data, so it can fire the "end" event.
  self.<span class="apidocCodeKeywordSpan">write</span>(data, encoding)

  if(self.feed === 'longpoll') {
var changes = [ DEFS.longpoll_header ].concat(self.buf).join('')
try { changes = JSON.parse(changes) || {} }
catch (er) { return self.error(er) }

if(!Array.isArray(changes.results))
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype.write_continuous" id="apidoc.module.follow.Changes.prototype.write_continuous">module follow.Changes.prototype.write_continuous</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.write_continuous.write_continuous" id="apidoc.element.follow.Changes.prototype.write_continuous.write_continuous">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_continuous
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write_continuous = function (data) {
  var self = this

  var offset, json, change
    , buf = (self.buf || "") + data

  self.log.debug('write: ' + util.inspect({'data':data, 'buf':buf}))

  // Buf could have 0, 1, or many JSON objects in it.
  while((offset = buf.indexOf("\n")) &gt;= 0) {
    json = buf.substr(0, offset);
    buf = buf.substr(offset + 1);
    self.log.debug('JSON: ' + util.inspect(json))

    // Heartbeats (empty strings) are fine, but otherwise confirm valid JSON.
    if(json === "")
      ;

    else if(json[0] !== '{')
      return self.error(new Error('Non-object JSON data: ' + json))

    else {
      try { change = JSON.parse(json) }
      catch (er) { return self.error(er) }

      self.log.debug('Object: ' + util.inspect(change))
      json = JSON.stringify(change)
    }

    // Change (or heartbeat) looks good.
    self.changes.push(json)
  }

  // Remember the unused data and send all known good changes (or heartbeats). The data (or heartbeat)
  // event listeners may call .pause() so remember the is_sending state now before calling them.
  var was_sending = self.is_sending
  self.buf = buf
  self.emit_changes()
  return was_sending
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
data = self.normalize_data(data, encoding)
if(typeof data != 'string')
  return // Looks like normalize_data emitted an error.

if(self.feed === 'longpoll')
  return self.write_longpoll(data)
else if(self.feed === 'continuous')
  return self.<span class="apidocCodeKeywordSpan">write_continuous</span>(data)
}


Changes.prototype.write_longpoll = function(data) {
var self = this

if(self.buf === null)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype.write_longpoll" id="apidoc.module.follow.Changes.prototype.write_longpoll">module follow.Changes.prototype.write_longpoll</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.write_longpoll.write_longpoll" id="apidoc.element.follow.Changes.prototype.write_longpoll.write_longpoll">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_longpoll
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write_longpoll = function (data) {
  var self = this

  if(self.buf === null)
    self.buf = []

  self.buf.push(data)
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var self = this

data = self.normalize_data(data, encoding)
if(typeof data != 'string')
  return // Looks like normalize_data emitted an error.

if(self.feed === 'longpoll')
  return self.<span class="apidocCodeKeywordSpan">write_longpoll</span>(data)
else if(self.feed === 'continuous')
  return self.write_continuous(data)
}


Changes.prototype.write_longpoll = function(data) {
var self = this
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed" id="apidoc.module.follow.Feed">module follow.Feed</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.Feed" id="apidoc.element.follow.Feed.Feed">
        function <span class="apidocSignatureSpan">follow.</span>Feed
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Feed(opts) {
  var self = this;
  EventEmitter.call(self);

  opts = opts || {}

  self.feed = 'continuous';
  self.heartbeat         = opts.heartbeat || DEFAULT_HEARTBEAT;
  self.max_retry_seconds = opts.max_retry_seconds || DEFAULT_MAX_RETRY_SECONDS;
  self.inactivity_ms = null;
  self.initial_retry_delay = opts.initial_retry_delay || INITIAL_RETRY_DELAY;
  self.response_grace_time = opts.response_grace_time || RESPONSE_GRACE_TIME;

  self.headers = {};
  self.request = opts.request || {} // Extra options for potentially future versions of request. The caller can supply them.

  self.since = 0;
  self.is_paused = false
  self.caught_up = false
  self.retry_delay = self.initial_retry_delay;

  self.query_params = {}; // Extra `req.query` values for filter functions

  if(typeof opts === 'string')
    opts = {'db': opts};

  Object.keys(opts).forEach(function(key) {
    if (typeof self[key] !== 'function')
      self[key] = opts[key];
  })

  self.pending = { request     : null
                 , activity_at : null
                 };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The main API is a thin wrapper around the EventEmitter API.

```javascript
var follow = require('follow');

var opts = {}; // Same options paramters as before
var feed = new follow.<span class="apidocCodeKeywordSpan">Feed</span>(opts);

// You can also set values directly.
feed.db            = "http://example.iriscouch.com/boogie";
feed.since         = 3;
feed.heartbeat     = 30    * 1000
feed.inactivity_ms = 86400 * 1000;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.super_" id="apidoc.element.follow.Feed.super_">
        function <span class="apidocSignatureSpan">follow.Feed.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype" id="apidoc.module.follow.Feed.prototype">module follow.Feed.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.check_for_catchup" id="apidoc.element.follow.Feed.prototype.check_for_catchup">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>check_for_catchup
        <span class="apidocSignatureSpan">(seq)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function check_for_catchup(seq) {
  var self = this

  if (self.is_db_updates)
    return
  if(self.caught_up)
    return
  if(seq &lt; self.original_db_seq)
    return

  self.caught_up = true
  self.emit('catchup', seq)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(result) {
  self.log.debug('Builtin filter PASS for change: ' + change.seq);
  return self.on_good_change(change);
} else {
  self.log.debug('Builtin filter FAIL for change: ' + change.seq);

  // Even with a filtered change, a "catchup" event might still be appropriate.
  self.<span class="apidocCodeKeywordSpan">check_for_catchup</span>(change.seq)
}
}

Feed.prototype.on_good_change = function on_good_change(change) {
var self = this;

if(self.inactivity_ms &amp;&amp; !self.inactivity_timer)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.confirm" id="apidoc.element.follow.Feed.prototype.confirm">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>confirm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function confirm_feed() {
  var self = this;

  self.db_safe = lib.scrub_creds(self.db);

  var endpoint = self.is_db_updates ? 'server' : 'database';

  self.log.debug('Checking ' + endpoint + ': ' + self.db_safe);

  var confirm_timeout = self.heartbeat * 3; // Give it time to look up the name, connect, etc.
  var timeout_id = setTimeout(function() {
    return self.die(new Error('Timeout confirming ' + endpoint + ': ' + self.db_safe));
  }, confirm_timeout);

  var headers = lib.JP(lib.JS(self.headers));
  headers.accept = 'application/json';

  var uri = self.is_db_updates ? self.db.replace(/\/_db_updates$/, '') : self.db;
  var req = {'uri':uri, 'headers':headers}
  Object.keys(self.request).forEach(function(key) {
    req[key] = self.request[key];
  })

  req = request(req, db_response)
  self.emit('confirm_request', req)

  function db_response(er, resp, body) {
    clearTimeout(timeout_id);

    if(er)
      return self.die(er);

    var db;
    try {
      db = JSON.parse(body)
    } catch(json_er) {
      return self.emit('error', json_er)
    }

    if(!self.is_db_updates &amp;&amp; !self.dead &amp;&amp; (!db.db_name || !db.instance_start_time))
      return self.emit('error', new Error('Bad DB response: ' + body));

    if(self.is_db_updates &amp;&amp; !self.dead &amp;&amp; !db.couchdb)
      return self.emit('error', new Error('Bad server response: ' + body));

    if (!self.is_db_updates)
      self.original_db_seq = db.update_seq

    self.log.debug('Confirmed ' + endpoint + ': ' + self.db_safe);
    self.emit('confirm', db);

    if(self.since == 'now') {
      self.log.debug('Query since "now" is the same as query since -1')
      self.since = -1
    }

    if(self.since == -1) {
      self.log.debug('Query since '+self.since+' will start at ' + db.update_seq)
      self.since = db.update_seq
    } else if(self.since &lt; 0) {
      if(isNaN(db.update_seq))
        return self.emit('error', new Error('DB requires specific id in "since"'));

      self.log.debug('Query since '+self.since+' will start at ' + (db.update_seq + self.since + 1))
      self.since = db.update_seq + self.since + 1
    }

    // If the next change would come after the current update_seq, just fake a catchup event now.
    if(self.original_db_seq == self.since) {
      self.caught_up = true
      self.emit('catchup', db.update_seq)
    }

    return self.query();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(typeof self.heartbeat !== 'number')
  throw new Error('Required "heartbeat" value');

self.log = lib.log4js.getLogger(self.db);
self.log.setLevel(process.env.follow_log_level || "info");

self.emit('start');
return self.<span class="apidocCodeKeywordSpan">confirm</span>();
}

Feed.prototype.confirm = function confirm_feed() {
var self = this;

self.db_safe = lib.scrub_creds(self.db);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.die" id="apidoc.element.follow.Feed.prototype.die">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>die
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">die = function (er) {
  var self = this;

  if(er)
    self.log.fatal('Fatal error: ' + er.stack);

  // Warn code executing later that death has occured.
  self.dead = true

  clearTimeout(self.retry_timer)
  clearTimeout(self.inactivity_timer)
  clearTimeout(self.pending.wait_timer)

  self.inactivity_timer = null
  self.pending.wait_timer = null

  var req = self.pending.request;
  self.pending.request = null;
  if(req) {
    self.log.debug('Destroying req ' + req.id());
    destroy_req(req);
  }

  if(er)
    self.emit('error', er);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var endpoint = self.is_db_updates ? 'server' : 'database';

self.log.debug('Checking ' + endpoint + ': ' + self.db_safe);

var confirm_timeout = self.heartbeat * 3; // Give it time to look up the name, connect, etc.
var timeout_id = setTimeout(function() {
  return self.<span class="apidocCodeKeywordSpan">die</span>(new Error('Timeout confirming ' + endpoint + ': '
; + self.db_safe));
}, confirm_timeout);

var headers = lib.JP(lib.JS(self.headers));
headers.accept = 'application/json';

var uri = self.is_db_updates ? self.db.replace(/\/_db_updates$/, '') : self.db;
var req = {'uri':uri, 'headers':headers}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.follow" id="apidoc.element.follow.Feed.prototype.follow">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>follow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function follow_feed() {
  var self = this;

  self.db = self.db || self.url || self.uri
  delete self.url
  delete self.uri

  if(!self.db)
    throw new Error('Database URL required');

  if (self.db.match(/\/_db_updates$/))
    self.is_db_updates = true;

  if(self.is_db_updates)
    delete self.since;

  if(self.feed !== 'continuous' &amp;&amp; self.feed !== 'longpoll')
    throw new Error('The only valid feed options are "continuous" and "longpoll"');

  if(typeof self.heartbeat !== 'number')
    throw new Error('Required "heartbeat" value');

  self.log = lib.log4js.getLogger(self.db);
  self.log.setLevel(process.env.follow_log_level || "info");

  self.emit('start');
  return self.confirm();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})

feed.on('error', function(er) {
  console.error('Since Follow always retries on errors, this must be serious');
  throw er;
})

feed.<span class="apidocCodeKeywordSpan">follow</span>();
```

&lt;a name="pause"&gt;&lt;/a&gt;
## Pause and Resume

A Follow feed is a Node.js stream. If you get lots of changes and processing them takes a while, use `.pause()` and `.resume()`
as needed. Pausing guarantees that no new events will fire. Resuming guarantees you'll pick up where you left off.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.got_activity" id="apidoc.element.follow.Feed.prototype.got_activity">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>got_activity
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">got_activity = function () {
  var self = this

  if (self.dead)
    return

  //
  // We may not have a wait_timer so just clear it and null it out if it does
  // exist
  //
  clearTimeout(self.pending.wait_timer)
  self.pending.wait_timer = null
  self.pending.activity_at = new Date
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.log.warn('No pending request to resume')
}


Feed.prototype.on_couch_heartbeat = function on_couch_heartbeat() {
var self = this

self.<span class="apidocCodeKeywordSpan">got_activity</span>()
if(self.dead)
  return self.log.debug('Skip heartbeat processing for dead feed')

self.emit('heartbeat')

if(self.dead)
  return self.log.debug('No wait: heartbeat listener stopped this feed')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_change" id="apidoc.element.follow.Feed.prototype.on_change">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_change
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_change(change) {
  var self = this;

  if(!self.is_db_updates &amp;&amp; !change.seq)
    return self.die(new Error('No seq value in change: ' + lib.JS(change)));

  if(!self.is_db_updates &amp;&amp; change.seq == self.since) {
    self.log.debug('Bad seq value ' + change.seq + ' since=' + self.since);
    return destroy_req(self.pending.request);
  }

  if(typeof self.filter !== 'function')
    return self.on_good_change(change);

  var req = lib.JDUP({'query': self.pending.request.changes_query});
  var filter_args;

  if (self.is_db_updates) {
    if(!change.db_name || !change.type)
      return self.die(new Error('Internal _db_updates filter needs .db_name and .type in change ', change));
    filter_args = [change.db_name, change.type, req];
  } else {
    if(!change.doc)
      return self.die(new Error('Internal filter needs .doc in change ' + change.seq));

    // Don't let the filter mutate the real data.
    var doc = lib.JDUP(change.doc);
    filter_args = [doc, req];
  }
  var result = false;
  try {
    result = self.filter.apply(null, filter_args);
  } catch (er) {
    self.log.debug('Filter error', er);
  }

  result = (result &amp;&amp; true) || false;
  if(result) {
    self.log.debug('Builtin filter PASS for change: ' + change.seq);
    return self.on_good_change(change);
  } else {
    self.log.debug('Builtin filter FAIL for change: ' + change.seq);

    // Even with a filtered change, a "catchup" event might still be appropriate.
    self.check_for_catchup(change.seq)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  del_er.last_seq = change.last_seq
  return self.die(del_er)
}

if(!self.is_db_updates &amp;&amp; !change.seq)
  return self.die(new Error('Change has no .seq field: ' + JSON.stringify(change)))

self.<span class="apidocCodeKeywordSpan">on_change</span>(change)

// on_change() might work its way all the way to a "change" event, and the listener
// might call .stop(), which means among other things that no more events are desired.
// The die() code sets a self.dead flag to indicate this.
if(self.dead)
  return self.log.debug('No wait: change listener stopped this feed')
self.wait()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_data" id="apidoc.element.follow.Feed.prototype.on_couch_data">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_data
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_data(change) {
  var self = this;
  self.log.debug('Data from ' + self.pending.request.id());

  self.got_activity()
  if(self.dead)
    return self.log.debug('Skip data processing for dead feed')

  // The changes stream guarantees that this data is valid JSON.
  change = JSON.parse(change)

  //self.log.debug('Object:\n' + util.inspect(change));
  if(!self.is_db_updates &amp;&amp; 'last_seq' in change) {
    self.log.warn('Stopping upon receiving a final message: ' + JSON.stringify(change))
    var del_er = new Error('Database deleted after change: ' + change.last_seq)
    del_er.deleted = true
    del_er.last_seq = change.last_seq
    return self.die(del_er)
  }

  if(!self.is_db_updates &amp;&amp; !change.seq)
    return self.die(new Error('Change has no .seq field: ' + JSON.stringify(change)))

  self.on_change(change)

  // on_change() might work its way all the way to a "change" event, and the listener
  // might call .stop(), which means among other things that no more events are desired.
  // The die() code sets a self.dead flag to indicate this.
  if(self.dead)
    return self.log.debug('No wait: change listener stopped this feed')
  self.wait()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_end" id="apidoc.element.follow.Feed.prototype.on_couch_end">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_end() {
  var self = this;

  self.log.debug('Changes feed ended ' + self.pending.request.id());
  self.pending.request = null;
  return self.retry();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_error" id="apidoc.element.follow.Feed.prototype.on_couch_error">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_error
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_error(er) {
  var self = this;

  self.log.debug('Changes query eror: ' + lib.JS(er.stack));
  return self.retry();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_heartbeat" id="apidoc.element.follow.Feed.prototype.on_couch_heartbeat">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_heartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_heartbeat() {
  var self = this

  self.got_activity()
  if(self.dead)
    return self.log.debug('Skip heartbeat processing for dead feed')

  self.emit('heartbeat')

  if(self.dead)
    return self.log.debug('No wait: heartbeat listener stopped this feed')
  self.wait()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_good_change" id="apidoc.element.follow.Feed.prototype.on_good_change">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_good_change
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_good_change(change) {
  var self = this;

  if(self.inactivity_ms &amp;&amp; !self.inactivity_timer)
    return self.die(new Error('Cannot find inactivity timer during change'));

  clearTimeout(self.inactivity_timer);
  self.inactivity_timer = null;
  if(self.inactivity_ms)
    self.inactivity_timer = setTimeout(function() { self.on_inactivity() }, self.inactivity_ms);

  self.change_at = new Date;

  if(!self.is_db_updates)
    self.since = change.seq;

  self.emit('change', change);

  self.check_for_catchup(change.seq)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if(!self.is_db_updates &amp;&amp; change.seq == self.since) {
  self.log.debug('Bad seq value ' + change.seq + ' since=' + self.since);
  return destroy_req(self.pending.request);
}

if(typeof self.filter !== 'function')
  return self.<span class="apidocCodeKeywordSpan">on_good_change</span>(change);

var req = lib.JDUP({'query': self.pending.request.changes_query});
var filter_args;

if (self.is_db_updates) {
  if(!change.db_name || !change.type)
    return self.die(new Error('Internal _db_updates filter needs .db_name and .type in change ', change));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_inactivity" id="apidoc.element.follow.Feed.prototype.on_inactivity">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_inactivity
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_inactivity() {
  var self = this;
  var now = new Date;
  var elapsed_ms = now - self.change_at;
  var elapsed_s  = elapsed_ms / 1000;

  //
  // Since this is actually not fatal, lets just totally reset and start a new
  // request, JUST in case something was bad.
  //
  self.log.debug('Req ' + self.pending.request.id() + ' made no changes for ' + elapsed_s + 's');
  return self.restart();

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.resume()

// The inactivity timer is for time between *changes*, or time between the
// initial connection and the first change. Therefore it goes here.
self.change_at = now;
if(self.inactivity_ms) {
  clearTimeout(self.inactivity_timer);
  self.inactivity_timer = setTimeout(function() { self.<span class="apidocCodeKeywordSpan">on_inactivity</span>() }, self.inactivity_ms
);
}

changes_stream.on('heartbeat', handler_for('heartbeat'))
changes_stream.on('error', handler_for('error'))
changes_stream.on('data', handler_for('data'))
changes_stream.on('end', handler_for('end'))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_timeout" id="apidoc.element.follow.Feed.prototype.on_timeout">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_timeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_timeout() {
  var self = this;
  if (self.dead)
    return self.log.debug('No timeout: change listener stopped this feed');

  self.log.debug('Timeout')

  var now = new Date;
  var elapsed_ms = now - self.pending.activity_at;

  self.emit('timeout', {elapsed_ms:elapsed_ms, heartbeat:self.heartbeat, id:self.pending.request.id()});

<span class="apidocCodeCommentSpan">  /*
  var msg = ' for timeout after ' + elapsed_ms + 'ms; heartbeat=' + self.heartbeat;
  if(!self.pending.request.id)
    self.log.warn('Closing req (no id) ' + msg + ' req=' + util.inspect(self.pending.request));
  else
    self.log.warn('Closing req ' + self.pending.request.id() + msg);
  */
</span>
  destroy_req(self.pending.request);
  self.retry()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var req_id = self.pending.request &amp;&amp; self.pending.request.id()
var msg = 'Req ' + req_id + ' timeout=' + timeout_ms;
if(self.inactivity_ms)
  msg += ', inactivity=' + self.inactivity_ms;
msg += ': ' + self.db_safe;

self.log.debug(msg);
self.pending.wait_timer = setTimeout(function() { self.<span class="apidocCodeKeywordSpan">on_timeout</span>() }, timeout_ms);
}

Feed.prototype.got_activity = function() {
var self = this

if (self.dead)
  return
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.pause" id="apidoc.element.follow.Feed.prototype.pause">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  var self = this
    , was_paused = self.is_paused

  // Emit pause after pausing the stream, to allow listeners to react.
  self.is_paused = true
  if(self.pending &amp;&amp; self.pending.request &amp;&amp; self.pending.request.pause)
    self.pending.request.pause()
  else
    self.log.warn('No pending request to pause')

  if(!was_paused)
    self.emit('pause')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

feed.follow();
```

&lt;a name="pause"&gt;&lt;/a&gt;
## Pause and Resume

A Follow feed is a Node.js stream. If you get lots of changes and processing them takes a while, use `.<span class="apidocCodeKeywordSpan
">pause</span>()` and `.resume()` as needed. Pausing guarantees that no new events will fire. Resuming guarantees you'll pick
 up where you left off.

```javascript
follow("https://example.iriscouch.com/boogie", function(error, change) {
var feed = this

if(change.seq == 1) {
  console.log('Uh oh. The first change takes 30 hours to process. Better pause.')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.prep" id="apidoc.element.follow.Feed.prototype.prep">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>prep
        <span class="apidocSignatureSpan">(changes_stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prep_request(changes_stream) {
  var self = this;

  var now = new Date;
  self.pending.request = changes_stream;
  self.pending.activity_at = now;
  self.pending.wait_timer  = null;

  // Just re-run the pause or resume to do the needful on changes_stream (self.pending.request).
  if(self.is_paused)
    self.pause()
  else
    self.resume()

  // The inactivity timer is for time between *changes*, or time between the
  // initial connection and the first change. Therefore it goes here.
  self.change_at = now;
  if(self.inactivity_ms) {
    clearTimeout(self.inactivity_timer);
    self.inactivity_timer = setTimeout(function() { self.on_inactivity() }, self.inactivity_ms);
  }

  changes_stream.on('heartbeat', handler_for('heartbeat'))
  changes_stream.on('error', handler_for('error'))
  changes_stream.on('data', handler_for('data'))
  changes_stream.on('end', handler_for('end'))

  return self.wait();

  function handler_for(ev) {
    var name = 'on_couch_' + ev;
    var inner_handler = self[name];

    return handle_confirmed_req_event;
    function handle_confirmed_req_event() {
      if(self.pending.request === changes_stream)
        return inner_handler.apply(self, arguments);

      if(!changes_stream.created_at)
        return self.die(new Error("Received data from unknown request")); // Pretty sure this is impossible.

      var s_to_now = (new Date() - changes_stream.created_at) / 1000;
      var s_to_req = '[no req]';
      if(self.pending.request)
        s_to_req = (self.pending.request.created_at - changes_stream.created_at) / 1000;

      var msg = ': ' + changes_stream.id() + ' to_req=' + s_to_req + 's, to_now=' + s_to_now + 's';

      if(ev == 'end' || ev == 'data' || ev == 'heartbeat') {
        self.log.debug('Old "' + ev + '": ' + changes_stream.id())
        return destroy_req(changes_stream)
      }

      self.log.warn('Old "'+ev+'"' + msg);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  changes_stream.log = lib.log4js.getLogger('stream ' + self.db)
  changes_stream.log.setLevel(self.log.level.levelStr)
  changes_stream.feed = self.feed
  feed_request.pipe(changes_stream)

  changes_stream.created_at = now
  changes_stream.id = function() { return feed_id }
  return self.<span class="apidocCodeKeywordSpan">prep</span>(changes_stream)
}
}

Feed.prototype.prep = function prep_request(changes_stream) {
var self = this;

var now = new Date;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.query" id="apidoc.element.follow.Feed.prototype.query">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>query
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query_feed() {
  var self = this;

  var query_params = JSON.parse(JSON.stringify(self.query_params));

  FEED_PARAMETERS.forEach(function(key) {
    if(key in self)
      query_params[key] = self[key];
  })

  if(typeof query_params.filter !== 'string')
    delete query_params.filter;

  if(typeof self.filter === 'function' &amp;&amp; !query_params.include_docs) {
    self.log.debug('Enabling include_docs for client-side filter');
    query_params.include_docs = true;
  }

  // Limit the response size for longpoll.
  var poll_size = 100;
  if(query_params.feed == 'longpoll' &amp;&amp; (!query_params.limit || query_params.limit &gt; poll_size))
    query_params.limit = poll_size;

  var feed_url = self.db + (self.is_db_updates ? '' : '/_changes') + '?' + querystring.stringify(query_params);

  self.headers.accept = self.headers.accept || 'application/json';
  var req = { method : 'GET'
            , uri    : feed_url
            , headers: self.headers
            , encoding: 'utf-8'
            }

  req.changes_query = query_params;
  Object.keys(self.request).forEach(function(key) {
    req[key] = self.request[key];
  })

  var now = new Date
    , feed_ts = lib.JDUP(now)
    , feed_id = process.env.follow_debug ? feed_ts.match(/\.(\d\d\d)Z$/)[1] : feed_ts

  self.log.debug('Feed query ' + feed_id + ': ' + lib.scrub_creds(feed_url))
  var feed_request = request(req)

  feed_request.on('response', function(res) {
    self.log.debug('Remove feed from agent pool: ' + feed_id)
    feed_request.req.socket.emit('agentRemove')

    // Simulate the old onResponse option.
    on_feed_response(null, res, res.body)
  })

  feed_request.on('error', on_feed_response)

  // The response headers must arrive within one heartbeat.
  var response_timer = setTimeout(response_timed_out, self.heartbeat + self.response_grace_time)
    , timed_out = false

  return self.emit('query', feed_request)

  function response_timed_out() {
    self.log.debug('Feed response timed out: ' + feed_id)
    timed_out = true
    return self.retry()
  }

  function on_feed_response(er, resp, body) {
    clearTimeout(response_timer)

    if((resp !== undefined &amp;&amp; resp.body) || body)
      return self.die(new Error('Cannot handle a body in the feed response: ' + lib.JS(resp.body || body)))

    if(timed_out) {
      self.log.debug('Ignoring late response: ' + feed_id);
      return destroy_response(resp);
    }

    if(er) {
      self.log.debug('Request error ' + feed_id + ': ' + er.stack);
      destroy_response(resp);
      return self.retry();
    }

    if(resp.statusCode !== 200) {
      self.log.debug('Bad changes response ' + feed_id + ': ' + resp.statusCode);
      destroy_response(resp);
      return self.retry();
    }

    self.log.debug('Good response: ' + feed_id);
    self.retry_delay = self.initial_retry_delay;

    self.emit('response', resp);

    var changes_stream = new Changes
    changes_stream.log = lib.log4js.getLogger('stream ' + self.db)
    changes_stream.log.setLevel(self.log.level.levelStr)
    changes_stream.feed = self.feed
    feed_request.pipe(changes_stream)

    changes_stream.created_at = now
    changes_stream.id = function() { return feed_id }
    return self.prep(changes_stream)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // If the next change would come after the current update_seq, just fake a catchup event now.
  if(self.original_db_seq == self.since) {
    self.caught_up = true
    self.emit('catchup', db.update_seq)
  }

  return self.<span class="apidocCodeKeywordSpan">query</span>();
}
}

Feed.prototype.query = function query_feed() {
var self = this;

var query_params = JSON.parse(JSON.stringify(self.query_params));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.restart" id="apidoc.element.follow.Feed.prototype.restart">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>restart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function restart() {
  var self = this

  self.emit('restart')

  // Kill ourselves and then start up once again
  self.stop()
  self.dead = false
  self.start()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var elapsed_s  = elapsed_ms / 1000;

//
// Since this is actually not fatal, lets just totally reset and start a new
// request, JUST in case something was bad.
//
self.log.debug('Req ' + self.pending.request.id() + ' made no changes for ' + elapsed_s + 's');
return self.<span class="apidocCodeKeywordSpan">restart</span>();

}

Feed.prototype.restart = function restart() {
var self = this

self.emit('restart')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.resume" id="apidoc.element.follow.Feed.prototype.resume">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  var self = this
    , was_paused = self.is_paused

  // Emit resume before resuming the data feed, to allow listeners to prepare.
  self.is_paused = false
  if(was_paused)
    self.emit('resume')

  if(self.pending &amp;&amp; self.pending.request &amp;&amp; self.pending.request.resume)
    self.pending.request.resume()
  else
    self.log.warn('No pending request to resume')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

feed.follow();
```

&lt;a name="pause"&gt;&lt;/a&gt;
## Pause and Resume

A Follow feed is a Node.js stream. If you get lots of changes and processing them takes a while, use `.pause()` and `.<span class="apidocCodeKeywordSpan">resume</span>()` as needed. Pausing guarantees that no new events will fire. Resuming guarantees you'
;ll pick up where you left off.

```javascript
follow("https://example.iriscouch.com/boogie", function(error, change) {
var feed = this

if(change.seq == 1) {
  console.log('Uh oh. The first change takes 30 hours to process. Better pause.')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.retry" id="apidoc.element.follow.Feed.prototype.retry">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>retry
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry() {
  var self = this;

  clearTimeout(self.pending.wait_timer);
  self.pending.wait_timer = null;

  self.log.debug('Retry since=' + self.since + ' after ' + self.retry_delay + 'ms ')
  self.emit('retry', {since:self.since, after:self.retry_delay, db:self.db_safe});

  self.retry_timer = setTimeout(function() { self.query() }, self.retry_delay);

  var max_retry_ms = self.max_retry_seconds * 1000;
  self.retry_delay *= 2;
  if(self.retry_delay &gt; max_retry_ms)
    self.retry_delay = max_retry_ms;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
, timed_out = false

  return self.emit('query', feed_request)

  function response_timed_out() {
self.log.debug('Feed response timed out: ' + feed_id)
timed_out = true
return self.<span class="apidocCodeKeywordSpan">retry</span>()
  }

  function on_feed_response(er, resp, body) {
clearTimeout(response_timer)

if((resp !== undefined &amp;&amp; resp.body) || body)
  return self.die(new Error('Cannot handle a body in the feed response: ' + lib.JS(resp.body || body)))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.start" id="apidoc.element.follow.Feed.prototype.start">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function follow_feed() {
  var self = this;

  self.db = self.db || self.url || self.uri
  delete self.url
  delete self.uri

  if(!self.db)
    throw new Error('Database URL required');

  if (self.db.match(/\/_db_updates$/))
    self.is_db_updates = true;

  if(self.is_db_updates)
    delete self.since;

  if(self.feed !== 'continuous' &amp;&amp; self.feed !== 'longpoll')
    throw new Error('The only valid feed options are "continuous" and "longpoll"');

  if(typeof self.heartbeat !== 'number')
    throw new Error('Required "heartbeat" value');

  self.log = lib.log4js.getLogger(self.db);
  self.log.setLevel(process.env.follow_log_level || "info");

  self.emit('start');
  return self.confirm();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var self = this

  self.emit('restart')

  // Kill ourselves and then start up once again
  self.stop()
  self.dead = false
  self.<span class="apidocCodeKeywordSpan">start</span>()
}

module.exports = { "Feed" : Feed
                 };


/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.stop" id="apidoc.element.follow.Feed.prototype.stop">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>stop
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (val) {
  var self = this
  self.log.debug('Stop')

  // Die with no errors.
  self.die()
  self.emit('stop', val);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* **catchup** | `function(seq_id)` | The feed has caught up to the *update_seq* from the confirm step. Assuming no subsequent changes
, you have seen all the data.
* **wait** | Follow is idle, waiting for the next data chunk from CouchDB
* **timeout** | `function(info)` | Follow did not receive a heartbeat from couch in time. The passed object has `.elapsed_ms` set
 to the elapsed time
* **retry** | `function(info)` | A retry is scheduled (usually after a timeout or disconnection). The passed object has
  * `.since` the current sequence id
  * `.after` the milliseconds to wait before the request occurs (on an exponential fallback schedule)
  * `.db` the database url (scrubbed of basic auth credentials)
* **stop** | The feed is stopping, because of an error, or because you called `feed.<span class="apidocCodeKeywordSpan">stop</span>()`
* **error** | `function(err)` | An error occurs

## Error conditions

Follow is happy to retry over and over, for all eternity. It will only emit an error if it thinks your whole application might be
 in trouble.

* *DB confirmation* failed: Follow confirms the DB with a preliminary query, which must reply properly.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.wait" id="apidoc.element.follow.Feed.prototype.wait">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>wait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wait_for_event() {
  var self = this;
  self.emit('wait');

  if(self.pending.wait_timer)
    return self.die(new Error('wait() called but there is already a wait_timer: ' + self.pending.wait_timer));

  var timeout_ms = self.heartbeat * HEARTBEAT_TIMEOUT_COEFFICIENT;
  var req_id = self.pending.request &amp;&amp; self.pending.request.id()
  var msg = 'Req ' + req_id + ' timeout=' + timeout_ms;
  if(self.inactivity_ms)
    msg += ', inactivity=' + self.inactivity_ms;
  msg += ': ' + self.db_safe;

  self.log.debug(msg);
  self.pending.wait_timer = setTimeout(function() { self.on_timeout() }, timeout_ms);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  changes_stream.on('heartbeat', handler_for('heartbeat'))
  changes_stream.on('error', handler_for('error'))
  changes_stream.on('data', handler_for('data'))
  changes_stream.on('end', handler_for('end'))

  return self.<span class="apidocCodeKeywordSpan">wait</span>();

  function handler_for(ev) {
var name = 'on_couch_' + ev;
var inner_handler = self[name];

return handle_confirmed_req_event;
function handle_confirmed_req_event() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.check_for_catchup" id="apidoc.module.follow.Feed.prototype.check_for_catchup">module follow.Feed.prototype.check_for_catchup</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.check_for_catchup.check_for_catchup" id="apidoc.element.follow.Feed.prototype.check_for_catchup.check_for_catchup">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>check_for_catchup
        <span class="apidocSignatureSpan">(seq)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function check_for_catchup(seq) {
  var self = this

  if (self.is_db_updates)
    return
  if(self.caught_up)
    return
  if(seq &lt; self.original_db_seq)
    return

  self.caught_up = true
  self.emit('catchup', seq)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(result) {
  self.log.debug('Builtin filter PASS for change: ' + change.seq);
  return self.on_good_change(change);
} else {
  self.log.debug('Builtin filter FAIL for change: ' + change.seq);

  // Even with a filtered change, a "catchup" event might still be appropriate.
  self.<span class="apidocCodeKeywordSpan">check_for_catchup</span>(change.seq)
}
}

Feed.prototype.on_good_change = function on_good_change(change) {
var self = this;

if(self.inactivity_ms &amp;&amp; !self.inactivity_timer)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.confirm" id="apidoc.module.follow.Feed.prototype.confirm">module follow.Feed.prototype.confirm</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.confirm.confirm" id="apidoc.element.follow.Feed.prototype.confirm.confirm">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>confirm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function confirm_feed() {
  var self = this;

  self.db_safe = lib.scrub_creds(self.db);

  var endpoint = self.is_db_updates ? 'server' : 'database';

  self.log.debug('Checking ' + endpoint + ': ' + self.db_safe);

  var confirm_timeout = self.heartbeat * 3; // Give it time to look up the name, connect, etc.
  var timeout_id = setTimeout(function() {
    return self.die(new Error('Timeout confirming ' + endpoint + ': ' + self.db_safe));
  }, confirm_timeout);

  var headers = lib.JP(lib.JS(self.headers));
  headers.accept = 'application/json';

  var uri = self.is_db_updates ? self.db.replace(/\/_db_updates$/, '') : self.db;
  var req = {'uri':uri, 'headers':headers}
  Object.keys(self.request).forEach(function(key) {
    req[key] = self.request[key];
  })

  req = request(req, db_response)
  self.emit('confirm_request', req)

  function db_response(er, resp, body) {
    clearTimeout(timeout_id);

    if(er)
      return self.die(er);

    var db;
    try {
      db = JSON.parse(body)
    } catch(json_er) {
      return self.emit('error', json_er)
    }

    if(!self.is_db_updates &amp;&amp; !self.dead &amp;&amp; (!db.db_name || !db.instance_start_time))
      return self.emit('error', new Error('Bad DB response: ' + body));

    if(self.is_db_updates &amp;&amp; !self.dead &amp;&amp; !db.couchdb)
      return self.emit('error', new Error('Bad server response: ' + body));

    if (!self.is_db_updates)
      self.original_db_seq = db.update_seq

    self.log.debug('Confirmed ' + endpoint + ': ' + self.db_safe);
    self.emit('confirm', db);

    if(self.since == 'now') {
      self.log.debug('Query since "now" is the same as query since -1')
      self.since = -1
    }

    if(self.since == -1) {
      self.log.debug('Query since '+self.since+' will start at ' + db.update_seq)
      self.since = db.update_seq
    } else if(self.since &lt; 0) {
      if(isNaN(db.update_seq))
        return self.emit('error', new Error('DB requires specific id in "since"'));

      self.log.debug('Query since '+self.since+' will start at ' + (db.update_seq + self.since + 1))
      self.since = db.update_seq + self.since + 1
    }

    // If the next change would come after the current update_seq, just fake a catchup event now.
    if(self.original_db_seq == self.since) {
      self.caught_up = true
      self.emit('catchup', db.update_seq)
    }

    return self.query();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(typeof self.heartbeat !== 'number')
  throw new Error('Required "heartbeat" value');

self.log = lib.log4js.getLogger(self.db);
self.log.setLevel(process.env.follow_log_level || "info");

self.emit('start');
return self.<span class="apidocCodeKeywordSpan">confirm</span>();
}

Feed.prototype.confirm = function confirm_feed() {
var self = this;

self.db_safe = lib.scrub_creds(self.db);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.die" id="apidoc.module.follow.Feed.prototype.die">module follow.Feed.prototype.die</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.die.die" id="apidoc.element.follow.Feed.prototype.die.die">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>die
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">die = function (er) {
  var self = this;

  if(er)
    self.log.fatal('Fatal error: ' + er.stack);

  // Warn code executing later that death has occured.
  self.dead = true

  clearTimeout(self.retry_timer)
  clearTimeout(self.inactivity_timer)
  clearTimeout(self.pending.wait_timer)

  self.inactivity_timer = null
  self.pending.wait_timer = null

  var req = self.pending.request;
  self.pending.request = null;
  if(req) {
    self.log.debug('Destroying req ' + req.id());
    destroy_req(req);
  }

  if(er)
    self.emit('error', er);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var endpoint = self.is_db_updates ? 'server' : 'database';

self.log.debug('Checking ' + endpoint + ': ' + self.db_safe);

var confirm_timeout = self.heartbeat * 3; // Give it time to look up the name, connect, etc.
var timeout_id = setTimeout(function() {
  return self.<span class="apidocCodeKeywordSpan">die</span>(new Error('Timeout confirming ' + endpoint + ': '
; + self.db_safe));
}, confirm_timeout);

var headers = lib.JP(lib.JS(self.headers));
headers.accept = 'application/json';

var uri = self.is_db_updates ? self.db.replace(/\/_db_updates$/, '') : self.db;
var req = {'uri':uri, 'headers':headers}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.follow" id="apidoc.module.follow.Feed.prototype.follow">module follow.Feed.prototype.follow</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.follow.follow" id="apidoc.element.follow.Feed.prototype.follow.follow">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>follow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function follow_feed() {
  var self = this;

  self.db = self.db || self.url || self.uri
  delete self.url
  delete self.uri

  if(!self.db)
    throw new Error('Database URL required');

  if (self.db.match(/\/_db_updates$/))
    self.is_db_updates = true;

  if(self.is_db_updates)
    delete self.since;

  if(self.feed !== 'continuous' &amp;&amp; self.feed !== 'longpoll')
    throw new Error('The only valid feed options are "continuous" and "longpoll"');

  if(typeof self.heartbeat !== 'number')
    throw new Error('Required "heartbeat" value');

  self.log = lib.log4js.getLogger(self.db);
  self.log.setLevel(process.env.follow_log_level || "info");

  self.emit('start');
  return self.confirm();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})

feed.on('error', function(er) {
  console.error('Since Follow always retries on errors, this must be serious');
  throw er;
})

feed.<span class="apidocCodeKeywordSpan">follow</span>();
```

&lt;a name="pause"&gt;&lt;/a&gt;
## Pause and Resume

A Follow feed is a Node.js stream. If you get lots of changes and processing them takes a while, use `.pause()` and `.resume()`
as needed. Pausing guarantees that no new events will fire. Resuming guarantees you'll pick up where you left off.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.got_activity" id="apidoc.module.follow.Feed.prototype.got_activity">module follow.Feed.prototype.got_activity</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.got_activity.got_activity" id="apidoc.element.follow.Feed.prototype.got_activity.got_activity">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>got_activity
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">got_activity = function () {
  var self = this

  if (self.dead)
    return

  //
  // We may not have a wait_timer so just clear it and null it out if it does
  // exist
  //
  clearTimeout(self.pending.wait_timer)
  self.pending.wait_timer = null
  self.pending.activity_at = new Date
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.log.warn('No pending request to resume')
}


Feed.prototype.on_couch_heartbeat = function on_couch_heartbeat() {
var self = this

self.<span class="apidocCodeKeywordSpan">got_activity</span>()
if(self.dead)
  return self.log.debug('Skip heartbeat processing for dead feed')

self.emit('heartbeat')

if(self.dead)
  return self.log.debug('No wait: heartbeat listener stopped this feed')
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.on_change" id="apidoc.module.follow.Feed.prototype.on_change">module follow.Feed.prototype.on_change</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_change.on_change" id="apidoc.element.follow.Feed.prototype.on_change.on_change">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_change
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_change(change) {
  var self = this;

  if(!self.is_db_updates &amp;&amp; !change.seq)
    return self.die(new Error('No seq value in change: ' + lib.JS(change)));

  if(!self.is_db_updates &amp;&amp; change.seq == self.since) {
    self.log.debug('Bad seq value ' + change.seq + ' since=' + self.since);
    return destroy_req(self.pending.request);
  }

  if(typeof self.filter !== 'function')
    return self.on_good_change(change);

  var req = lib.JDUP({'query': self.pending.request.changes_query});
  var filter_args;

  if (self.is_db_updates) {
    if(!change.db_name || !change.type)
      return self.die(new Error('Internal _db_updates filter needs .db_name and .type in change ', change));
    filter_args = [change.db_name, change.type, req];
  } else {
    if(!change.doc)
      return self.die(new Error('Internal filter needs .doc in change ' + change.seq));

    // Don't let the filter mutate the real data.
    var doc = lib.JDUP(change.doc);
    filter_args = [doc, req];
  }
  var result = false;
  try {
    result = self.filter.apply(null, filter_args);
  } catch (er) {
    self.log.debug('Filter error', er);
  }

  result = (result &amp;&amp; true) || false;
  if(result) {
    self.log.debug('Builtin filter PASS for change: ' + change.seq);
    return self.on_good_change(change);
  } else {
    self.log.debug('Builtin filter FAIL for change: ' + change.seq);

    // Even with a filtered change, a "catchup" event might still be appropriate.
    self.check_for_catchup(change.seq)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  del_er.last_seq = change.last_seq
  return self.die(del_er)
}

if(!self.is_db_updates &amp;&amp; !change.seq)
  return self.die(new Error('Change has no .seq field: ' + JSON.stringify(change)))

self.<span class="apidocCodeKeywordSpan">on_change</span>(change)

// on_change() might work its way all the way to a "change" event, and the listener
// might call .stop(), which means among other things that no more events are desired.
// The die() code sets a self.dead flag to indicate this.
if(self.dead)
  return self.log.debug('No wait: change listener stopped this feed')
self.wait()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.on_couch_data" id="apidoc.module.follow.Feed.prototype.on_couch_data">module follow.Feed.prototype.on_couch_data</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_data.on_couch_data" id="apidoc.element.follow.Feed.prototype.on_couch_data.on_couch_data">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_data
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_data(change) {
  var self = this;
  self.log.debug('Data from ' + self.pending.request.id());

  self.got_activity()
  if(self.dead)
    return self.log.debug('Skip data processing for dead feed')

  // The changes stream guarantees that this data is valid JSON.
  change = JSON.parse(change)

  //self.log.debug('Object:\n' + util.inspect(change));
  if(!self.is_db_updates &amp;&amp; 'last_seq' in change) {
    self.log.warn('Stopping upon receiving a final message: ' + JSON.stringify(change))
    var del_er = new Error('Database deleted after change: ' + change.last_seq)
    del_er.deleted = true
    del_er.last_seq = change.last_seq
    return self.die(del_er)
  }

  if(!self.is_db_updates &amp;&amp; !change.seq)
    return self.die(new Error('Change has no .seq field: ' + JSON.stringify(change)))

  self.on_change(change)

  // on_change() might work its way all the way to a "change" event, and the listener
  // might call .stop(), which means among other things that no more events are desired.
  // The die() code sets a self.dead flag to indicate this.
  if(self.dead)
    return self.log.debug('No wait: change listener stopped this feed')
  self.wait()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.on_couch_end" id="apidoc.module.follow.Feed.prototype.on_couch_end">module follow.Feed.prototype.on_couch_end</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_end.on_couch_end" id="apidoc.element.follow.Feed.prototype.on_couch_end.on_couch_end">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_end() {
  var self = this;

  self.log.debug('Changes feed ended ' + self.pending.request.id());
  self.pending.request = null;
  return self.retry();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.on_couch_error" id="apidoc.module.follow.Feed.prototype.on_couch_error">module follow.Feed.prototype.on_couch_error</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_error.on_couch_error" id="apidoc.element.follow.Feed.prototype.on_couch_error.on_couch_error">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_error
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_error(er) {
  var self = this;

  self.log.debug('Changes query eror: ' + lib.JS(er.stack));
  return self.retry();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.on_couch_heartbeat" id="apidoc.module.follow.Feed.prototype.on_couch_heartbeat">module follow.Feed.prototype.on_couch_heartbeat</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_heartbeat.on_couch_heartbeat" id="apidoc.element.follow.Feed.prototype.on_couch_heartbeat.on_couch_heartbeat">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_heartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_heartbeat() {
  var self = this

  self.got_activity()
  if(self.dead)
    return self.log.debug('Skip heartbeat processing for dead feed')

  self.emit('heartbeat')

  if(self.dead)
    return self.log.debug('No wait: heartbeat listener stopped this feed')
  self.wait()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.on_good_change" id="apidoc.module.follow.Feed.prototype.on_good_change">module follow.Feed.prototype.on_good_change</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_good_change.on_good_change" id="apidoc.element.follow.Feed.prototype.on_good_change.on_good_change">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_good_change
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_good_change(change) {
  var self = this;

  if(self.inactivity_ms &amp;&amp; !self.inactivity_timer)
    return self.die(new Error('Cannot find inactivity timer during change'));

  clearTimeout(self.inactivity_timer);
  self.inactivity_timer = null;
  if(self.inactivity_ms)
    self.inactivity_timer = setTimeout(function() { self.on_inactivity() }, self.inactivity_ms);

  self.change_at = new Date;

  if(!self.is_db_updates)
    self.since = change.seq;

  self.emit('change', change);

  self.check_for_catchup(change.seq)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if(!self.is_db_updates &amp;&amp; change.seq == self.since) {
  self.log.debug('Bad seq value ' + change.seq + ' since=' + self.since);
  return destroy_req(self.pending.request);
}

if(typeof self.filter !== 'function')
  return self.<span class="apidocCodeKeywordSpan">on_good_change</span>(change);

var req = lib.JDUP({'query': self.pending.request.changes_query});
var filter_args;

if (self.is_db_updates) {
  if(!change.db_name || !change.type)
    return self.die(new Error('Internal _db_updates filter needs .db_name and .type in change ', change));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.on_inactivity" id="apidoc.module.follow.Feed.prototype.on_inactivity">module follow.Feed.prototype.on_inactivity</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_inactivity.on_inactivity" id="apidoc.element.follow.Feed.prototype.on_inactivity.on_inactivity">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_inactivity
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_inactivity() {
  var self = this;
  var now = new Date;
  var elapsed_ms = now - self.change_at;
  var elapsed_s  = elapsed_ms / 1000;

  //
  // Since this is actually not fatal, lets just totally reset and start a new
  // request, JUST in case something was bad.
  //
  self.log.debug('Req ' + self.pending.request.id() + ' made no changes for ' + elapsed_s + 's');
  return self.restart();

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.resume()

// The inactivity timer is for time between *changes*, or time between the
// initial connection and the first change. Therefore it goes here.
self.change_at = now;
if(self.inactivity_ms) {
  clearTimeout(self.inactivity_timer);
  self.inactivity_timer = setTimeout(function() { self.<span class="apidocCodeKeywordSpan">on_inactivity</span>() }, self.inactivity_ms
);
}

changes_stream.on('heartbeat', handler_for('heartbeat'))
changes_stream.on('error', handler_for('error'))
changes_stream.on('data', handler_for('data'))
changes_stream.on('end', handler_for('end'))
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.on_timeout" id="apidoc.module.follow.Feed.prototype.on_timeout">module follow.Feed.prototype.on_timeout</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_timeout.on_timeout" id="apidoc.element.follow.Feed.prototype.on_timeout.on_timeout">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_timeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_timeout() {
  var self = this;
  if (self.dead)
    return self.log.debug('No timeout: change listener stopped this feed');

  self.log.debug('Timeout')

  var now = new Date;
  var elapsed_ms = now - self.pending.activity_at;

  self.emit('timeout', {elapsed_ms:elapsed_ms, heartbeat:self.heartbeat, id:self.pending.request.id()});

<span class="apidocCodeCommentSpan">  /*
  var msg = ' for timeout after ' + elapsed_ms + 'ms; heartbeat=' + self.heartbeat;
  if(!self.pending.request.id)
    self.log.warn('Closing req (no id) ' + msg + ' req=' + util.inspect(self.pending.request));
  else
    self.log.warn('Closing req ' + self.pending.request.id() + msg);
  */
</span>
  destroy_req(self.pending.request);
  self.retry()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var req_id = self.pending.request &amp;&amp; self.pending.request.id()
var msg = 'Req ' + req_id + ' timeout=' + timeout_ms;
if(self.inactivity_ms)
  msg += ', inactivity=' + self.inactivity_ms;
msg += ': ' + self.db_safe;

self.log.debug(msg);
self.pending.wait_timer = setTimeout(function() { self.<span class="apidocCodeKeywordSpan">on_timeout</span>() }, timeout_ms);
}

Feed.prototype.got_activity = function() {
var self = this

if (self.dead)
  return
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.pause" id="apidoc.module.follow.Feed.prototype.pause">module follow.Feed.prototype.pause</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.pause.pause" id="apidoc.element.follow.Feed.prototype.pause.pause">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  var self = this
    , was_paused = self.is_paused

  // Emit pause after pausing the stream, to allow listeners to react.
  self.is_paused = true
  if(self.pending &amp;&amp; self.pending.request &amp;&amp; self.pending.request.pause)
    self.pending.request.pause()
  else
    self.log.warn('No pending request to pause')

  if(!was_paused)
    self.emit('pause')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

feed.follow();
```

&lt;a name="pause"&gt;&lt;/a&gt;
## Pause and Resume

A Follow feed is a Node.js stream. If you get lots of changes and processing them takes a while, use `.<span class="apidocCodeKeywordSpan
">pause</span>()` and `.resume()` as needed. Pausing guarantees that no new events will fire. Resuming guarantees you'll pick
 up where you left off.

```javascript
follow("https://example.iriscouch.com/boogie", function(error, change) {
var feed = this

if(change.seq == 1) {
  console.log('Uh oh. The first change takes 30 hours to process. Better pause.')
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.prep" id="apidoc.module.follow.Feed.prototype.prep">module follow.Feed.prototype.prep</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.prep.prep" id="apidoc.element.follow.Feed.prototype.prep.prep">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>prep
        <span class="apidocSignatureSpan">(changes_stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prep_request(changes_stream) {
  var self = this;

  var now = new Date;
  self.pending.request = changes_stream;
  self.pending.activity_at = now;
  self.pending.wait_timer  = null;

  // Just re-run the pause or resume to do the needful on changes_stream (self.pending.request).
  if(self.is_paused)
    self.pause()
  else
    self.resume()

  // The inactivity timer is for time between *changes*, or time between the
  // initial connection and the first change. Therefore it goes here.
  self.change_at = now;
  if(self.inactivity_ms) {
    clearTimeout(self.inactivity_timer);
    self.inactivity_timer = setTimeout(function() { self.on_inactivity() }, self.inactivity_ms);
  }

  changes_stream.on('heartbeat', handler_for('heartbeat'))
  changes_stream.on('error', handler_for('error'))
  changes_stream.on('data', handler_for('data'))
  changes_stream.on('end', handler_for('end'))

  return self.wait();

  function handler_for(ev) {
    var name = 'on_couch_' + ev;
    var inner_handler = self[name];

    return handle_confirmed_req_event;
    function handle_confirmed_req_event() {
      if(self.pending.request === changes_stream)
        return inner_handler.apply(self, arguments);

      if(!changes_stream.created_at)
        return self.die(new Error("Received data from unknown request")); // Pretty sure this is impossible.

      var s_to_now = (new Date() - changes_stream.created_at) / 1000;
      var s_to_req = '[no req]';
      if(self.pending.request)
        s_to_req = (self.pending.request.created_at - changes_stream.created_at) / 1000;

      var msg = ': ' + changes_stream.id() + ' to_req=' + s_to_req + 's, to_now=' + s_to_now + 's';

      if(ev == 'end' || ev == 'data' || ev == 'heartbeat') {
        self.log.debug('Old "' + ev + '": ' + changes_stream.id())
        return destroy_req(changes_stream)
      }

      self.log.warn('Old "'+ev+'"' + msg);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  changes_stream.log = lib.log4js.getLogger('stream ' + self.db)
  changes_stream.log.setLevel(self.log.level.levelStr)
  changes_stream.feed = self.feed
  feed_request.pipe(changes_stream)

  changes_stream.created_at = now
  changes_stream.id = function() { return feed_id }
  return self.<span class="apidocCodeKeywordSpan">prep</span>(changes_stream)
}
}

Feed.prototype.prep = function prep_request(changes_stream) {
var self = this;

var now = new Date;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.query" id="apidoc.module.follow.Feed.prototype.query">module follow.Feed.prototype.query</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.query.query" id="apidoc.element.follow.Feed.prototype.query.query">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>query
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query_feed() {
  var self = this;

  var query_params = JSON.parse(JSON.stringify(self.query_params));

  FEED_PARAMETERS.forEach(function(key) {
    if(key in self)
      query_params[key] = self[key];
  })

  if(typeof query_params.filter !== 'string')
    delete query_params.filter;

  if(typeof self.filter === 'function' &amp;&amp; !query_params.include_docs) {
    self.log.debug('Enabling include_docs for client-side filter');
    query_params.include_docs = true;
  }

  // Limit the response size for longpoll.
  var poll_size = 100;
  if(query_params.feed == 'longpoll' &amp;&amp; (!query_params.limit || query_params.limit &gt; poll_size))
    query_params.limit = poll_size;

  var feed_url = self.db + (self.is_db_updates ? '' : '/_changes') + '?' + querystring.stringify(query_params);

  self.headers.accept = self.headers.accept || 'application/json';
  var req = { method : 'GET'
            , uri    : feed_url
            , headers: self.headers
            , encoding: 'utf-8'
            }

  req.changes_query = query_params;
  Object.keys(self.request).forEach(function(key) {
    req[key] = self.request[key];
  })

  var now = new Date
    , feed_ts = lib.JDUP(now)
    , feed_id = process.env.follow_debug ? feed_ts.match(/\.(\d\d\d)Z$/)[1] : feed_ts

  self.log.debug('Feed query ' + feed_id + ': ' + lib.scrub_creds(feed_url))
  var feed_request = request(req)

  feed_request.on('response', function(res) {
    self.log.debug('Remove feed from agent pool: ' + feed_id)
    feed_request.req.socket.emit('agentRemove')

    // Simulate the old onResponse option.
    on_feed_response(null, res, res.body)
  })

  feed_request.on('error', on_feed_response)

  // The response headers must arrive within one heartbeat.
  var response_timer = setTimeout(response_timed_out, self.heartbeat + self.response_grace_time)
    , timed_out = false

  return self.emit('query', feed_request)

  function response_timed_out() {
    self.log.debug('Feed response timed out: ' + feed_id)
    timed_out = true
    return self.retry()
  }

  function on_feed_response(er, resp, body) {
    clearTimeout(response_timer)

    if((resp !== undefined &amp;&amp; resp.body) || body)
      return self.die(new Error('Cannot handle a body in the feed response: ' + lib.JS(resp.body || body)))

    if(timed_out) {
      self.log.debug('Ignoring late response: ' + feed_id);
      return destroy_response(resp);
    }

    if(er) {
      self.log.debug('Request error ' + feed_id + ': ' + er.stack);
      destroy_response(resp);
      return self.retry();
    }

    if(resp.statusCode !== 200) {
      self.log.debug('Bad changes response ' + feed_id + ': ' + resp.statusCode);
      destroy_response(resp);
      return self.retry();
    }

    self.log.debug('Good response: ' + feed_id);
    self.retry_delay = self.initial_retry_delay;

    self.emit('response', resp);

    var changes_stream = new Changes
    changes_stream.log = lib.log4js.getLogger('stream ' + self.db)
    changes_stream.log.setLevel(self.log.level.levelStr)
    changes_stream.feed = self.feed
    feed_request.pipe(changes_stream)

    changes_stream.created_at = now
    changes_stream.id = function() { return feed_id }
    return self.prep(changes_stream)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // If the next change would come after the current update_seq, just fake a catchup event now.
  if(self.original_db_seq == self.since) {
    self.caught_up = true
    self.emit('catchup', db.update_seq)
  }

  return self.<span class="apidocCodeKeywordSpan">query</span>();
}
}

Feed.prototype.query = function query_feed() {
var self = this;

var query_params = JSON.parse(JSON.stringify(self.query_params));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.restart" id="apidoc.module.follow.Feed.prototype.restart">module follow.Feed.prototype.restart</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.restart.restart" id="apidoc.element.follow.Feed.prototype.restart.restart">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>restart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function restart() {
  var self = this

  self.emit('restart')

  // Kill ourselves and then start up once again
  self.stop()
  self.dead = false
  self.start()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var elapsed_s  = elapsed_ms / 1000;

//
// Since this is actually not fatal, lets just totally reset and start a new
// request, JUST in case something was bad.
//
self.log.debug('Req ' + self.pending.request.id() + ' made no changes for ' + elapsed_s + 's');
return self.<span class="apidocCodeKeywordSpan">restart</span>();

}

Feed.prototype.restart = function restart() {
var self = this

self.emit('restart')
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.resume" id="apidoc.module.follow.Feed.prototype.resume">module follow.Feed.prototype.resume</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.resume.resume" id="apidoc.element.follow.Feed.prototype.resume.resume">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  var self = this
    , was_paused = self.is_paused

  // Emit resume before resuming the data feed, to allow listeners to prepare.
  self.is_paused = false
  if(was_paused)
    self.emit('resume')

  if(self.pending &amp;&amp; self.pending.request &amp;&amp; self.pending.request.resume)
    self.pending.request.resume()
  else
    self.log.warn('No pending request to resume')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

feed.follow();
```

&lt;a name="pause"&gt;&lt;/a&gt;
## Pause and Resume

A Follow feed is a Node.js stream. If you get lots of changes and processing them takes a while, use `.pause()` and `.<span class="apidocCodeKeywordSpan">resume</span>()` as needed. Pausing guarantees that no new events will fire. Resuming guarantees you'
;ll pick up where you left off.

```javascript
follow("https://example.iriscouch.com/boogie", function(error, change) {
var feed = this

if(change.seq == 1) {
  console.log('Uh oh. The first change takes 30 hours to process. Better pause.')
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.retry" id="apidoc.module.follow.Feed.prototype.retry">module follow.Feed.prototype.retry</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.retry.retry" id="apidoc.element.follow.Feed.prototype.retry.retry">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>retry
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry() {
  var self = this;

  clearTimeout(self.pending.wait_timer);
  self.pending.wait_timer = null;

  self.log.debug('Retry since=' + self.since + ' after ' + self.retry_delay + 'ms ')
  self.emit('retry', {since:self.since, after:self.retry_delay, db:self.db_safe});

  self.retry_timer = setTimeout(function() { self.query() }, self.retry_delay);

  var max_retry_ms = self.max_retry_seconds * 1000;
  self.retry_delay *= 2;
  if(self.retry_delay &gt; max_retry_ms)
    self.retry_delay = max_retry_ms;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
, timed_out = false

  return self.emit('query', feed_request)

  function response_timed_out() {
self.log.debug('Feed response timed out: ' + feed_id)
timed_out = true
return self.<span class="apidocCodeKeywordSpan">retry</span>()
  }

  function on_feed_response(er, resp, body) {
clearTimeout(response_timer)

if((resp !== undefined &amp;&amp; resp.body) || body)
  return self.die(new Error('Cannot handle a body in the feed response: ' + lib.JS(resp.body || body)))
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.stop" id="apidoc.module.follow.Feed.prototype.stop">module follow.Feed.prototype.stop</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.stop.stop" id="apidoc.element.follow.Feed.prototype.stop.stop">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>stop
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (val) {
  var self = this
  self.log.debug('Stop')

  // Die with no errors.
  self.die()
  self.emit('stop', val);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* **catchup** | `function(seq_id)` | The feed has caught up to the *update_seq* from the confirm step. Assuming no subsequent changes
, you have seen all the data.
* **wait** | Follow is idle, waiting for the next data chunk from CouchDB
* **timeout** | `function(info)` | Follow did not receive a heartbeat from couch in time. The passed object has `.elapsed_ms` set
 to the elapsed time
* **retry** | `function(info)` | A retry is scheduled (usually after a timeout or disconnection). The passed object has
  * `.since` the current sequence id
  * `.after` the milliseconds to wait before the request occurs (on an exponential fallback schedule)
  * `.db` the database url (scrubbed of basic auth credentials)
* **stop** | The feed is stopping, because of an error, or because you called `feed.<span class="apidocCodeKeywordSpan">stop</span>()`
* **error** | `function(err)` | An error occurs

## Error conditions

Follow is happy to retry over and over, for all eternity. It will only emit an error if it thinks your whole application might be
 in trouble.

* *DB confirmation* failed: Follow confirms the DB with a preliminary query, which must reply properly.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype.wait" id="apidoc.module.follow.Feed.prototype.wait">module follow.Feed.prototype.wait</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.wait.wait" id="apidoc.element.follow.Feed.prototype.wait.wait">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>wait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wait_for_event() {
  var self = this;
  self.emit('wait');

  if(self.pending.wait_timer)
    return self.die(new Error('wait() called but there is already a wait_timer: ' + self.pending.wait_timer));

  var timeout_ms = self.heartbeat * HEARTBEAT_TIMEOUT_COEFFICIENT;
  var req_id = self.pending.request &amp;&amp; self.pending.request.id()
  var msg = 'Req ' + req_id + ' timeout=' + timeout_ms;
  if(self.inactivity_ms)
    msg += ', inactivity=' + self.inactivity_ms;
  msg += ': ' + self.db_safe;

  self.log.debug(msg);
  self.pending.wait_timer = setTimeout(function() { self.on_timeout() }, timeout_ms);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  changes_stream.on('heartbeat', handler_for('heartbeat'))
  changes_stream.on('error', handler_for('error'))
  changes_stream.on('data', handler_for('data'))
  changes_stream.on('end', handler_for('end'))

  return self.<span class="apidocCodeKeywordSpan">wait</span>();

  function handler_for(ev) {
var name = 'on_couch_' + ev;
var inner_handler = self[name];

return handle_confirmed_req_event;
function handle_confirmed_req_event() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.eventemitter2" id="apidoc.module.follow.eventemitter2">module follow.eventemitter2</a></h1>


    <h2>
        <a href="#apidoc.element.follow.eventemitter2.EventEmitter2" id="apidoc.element.follow.eventemitter2.EventEmitter2">
        function <span class="apidocSignatureSpan">follow.eventemitter2.</span>EventEmitter2
        <span class="apidocSignatureSpan">(conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter(conf) {
  this._events = new Object;
  configure.call(this, conf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.feed" id="apidoc.module.follow.feed">module follow.feed</a></h1>


    <h2>
        <a href="#apidoc.element.follow.feed.Feed" id="apidoc.element.follow.feed.Feed">
        function <span class="apidocSignatureSpan">follow.feed.</span>Feed
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Feed(opts) {
  var self = this;
  EventEmitter.call(self);

  opts = opts || {}

  self.feed = 'continuous';
  self.heartbeat         = opts.heartbeat || DEFAULT_HEARTBEAT;
  self.max_retry_seconds = opts.max_retry_seconds || DEFAULT_MAX_RETRY_SECONDS;
  self.inactivity_ms = null;
  self.initial_retry_delay = opts.initial_retry_delay || INITIAL_RETRY_DELAY;
  self.response_grace_time = opts.response_grace_time || RESPONSE_GRACE_TIME;

  self.headers = {};
  self.request = opts.request || {} // Extra options for potentially future versions of request. The caller can supply them.

  self.since = 0;
  self.is_paused = false
  self.caught_up = false
  self.retry_delay = self.initial_retry_delay;

  self.query_params = {}; // Extra `req.query` values for filter functions

  if(typeof opts === 'string')
    opts = {'db': opts};

  Object.keys(opts).forEach(function(key) {
    if (typeof self[key] !== 'function')
      self[key] = opts[key];
  })

  self.pending = { request     : null
                 , activity_at : null
                 };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The main API is a thin wrapper around the EventEmitter API.

```javascript
var follow = require('follow');

var opts = {}; // Same options paramters as before
var feed = new follow.<span class="apidocCodeKeywordSpan">Feed</span>(opts);

// You can also set values directly.
feed.db            = "http://example.iriscouch.com/boogie";
feed.since         = 3;
feed.heartbeat     = 30    * 1000
feed.inactivity_ms = 86400 * 1000;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.stream" id="apidoc.module.follow.stream">module follow.stream</a></h1>


    <h2>
        <a href="#apidoc.element.follow.stream.Changes" id="apidoc.element.follow.stream.Changes">
        function <span class="apidocSignatureSpan">follow.stream.</span>Changes
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Changes(opts) {
  var self = this
  stream.call(self)

  self.readable = true
  self.writable = true

  self.headers = {}
  self.statusCode = null

  opts = opts || {}
  self.feed = opts.feed || null // "continuous" or "longpoll"
  self.encoding = opts.encoding || 'utf8'

  self.log = opts.log
  if(!self.log) {
    self.log = lib.log4js.getLogger('change_stream')
    self.log.setLevel(DEFS.log_level)
  }

  self.is_sending = true
  self.is_ending = false
  self.is_dead = false

  self.source = null
  self.expect = null
  self.buf = null
  self.changes = []

  self.on('pipe', function(src) {
    if(!self.source)
      self.source = src
    else {
      var er = new Error('Already have a pipe source')
      er.source = self.source
      self.error(er)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.toString" id="apidoc.module.follow.toString">module follow.toString</a></h1>


    <h2>
        <a href="#apidoc.element.follow.toString.toString" id="apidoc.element.follow.toString.toString">
        function <span class="apidocSignatureSpan">follow.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function install(filename, target, callback) {
  //console.log('Exporting: ' + filename);
  fs.readFile(filename, null, function(er, content) {
if(er &amp;&amp; er.errno) er = new Error(er.stack); // Make a better stack trace.
if(er) return callback(er);

// Strip the shebang.
content = content.<span class="apidocCodeKeywordSpan">toString</span>('utf8');
var content_lines = content.split(/\n/);
content_lines[0] = content_lines[0].replace(/^(#!.*)$/, '// $1');

// TODO
// content_lines.join('\n'), maybe new Buffer of that

//Convert the Node module (CommonJS) to RequireJS.
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>