<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://github.com/iriscouch/follow">follow (v0.12.1)</a>
</h1>
<h4>Extremely robust, fault-tolerant CouchDB changes follower</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow">module follow</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.follow">
            function <span class="apidocSignatureSpan"></span>follow
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes">
            function <span class="apidocSignatureSpan">follow.</span>Changes
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed">
            function <span class="apidocSignatureSpan">follow.</span>Feed
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>Changes.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>Feed.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>cli</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>eventemitter2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>feed</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>index</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.</span>stream</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes">module follow.Changes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.Changes">
            function <span class="apidocSignatureSpan">follow.</span>Changes
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.super_">
            function <span class="apidocSignatureSpan">follow.Changes.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Changes.prototype">module follow.Changes.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.destroy">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.destroySoon">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroySoon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.emit_changes">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>emit_changes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.end">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>end
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.error">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>error
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.normalize_data">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>normalize_data
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.pause">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.resume">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.setEncoding">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setEncoding
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.setHeader">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setHeader
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.write">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.write_continuous">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_continuous
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Changes.prototype.write_longpoll">
            function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_longpoll
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed">module follow.Feed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.Feed">
            function <span class="apidocSignatureSpan">follow.</span>Feed
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.super_">
            function <span class="apidocSignatureSpan">follow.Feed.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.Feed.prototype">module follow.Feed.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.check_for_catchup">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>check_for_catchup
            <span class="apidocSignatureSpan">(seq)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.confirm">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>confirm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.die">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>die
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.follow">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>follow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.got_activity">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>got_activity
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_change">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_change
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_data">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_data
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_end">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_error">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_error
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_couch_heartbeat">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_heartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_good_change">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_good_change
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_inactivity">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_inactivity
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.on_timeout">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_timeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.pause">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.prep">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>prep
            <span class="apidocSignatureSpan">(changes_stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.query">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>query
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.restart">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>restart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.resume">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.retry">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>retry
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.start">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.stop">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>stop
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.Feed.prototype.wait">
            function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>wait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.cli">module follow.cli</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.cli.main">
            function <span class="apidocSignatureSpan">follow.cli.</span>main
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.eventemitter2">module follow.eventemitter2</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.eventemitter2.EventEmitter2">
            function <span class="apidocSignatureSpan">follow.eventemitter2.</span>EventEmitter2
            <span class="apidocSignatureSpan">(conf)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.feed">module follow.feed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.feed.Feed">
            function <span class="apidocSignatureSpan">follow.feed.</span>Feed
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.index">module follow.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.index.JDUP">
            function <span class="apidocSignatureSpan">follow.index.</span>JDUP
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.index.JP">
            function <span class="apidocSignatureSpan">follow.index.</span>JP
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.index.JS">
            function <span class="apidocSignatureSpan">follow.index.</span>JS
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.index.clearTimeout">
            function <span class="apidocSignatureSpan">follow.index.</span>clearTimeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.index.scrub_creds">
            function <span class="apidocSignatureSpan">follow.index.</span>scrub_creds
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.index.setTimeout">
            function <span class="apidocSignatureSpan">follow.index.</span>setTimeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.index.timeouts">
            function <span class="apidocSignatureSpan">follow.index.</span>timeouts
            <span class="apidocSignatureSpan">(set, clear)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">follow.index.</span>log4js</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.follow.stream">module follow.stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.follow.stream.Changes">
            function <span class="apidocSignatureSpan">follow.stream.</span>Changes
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow" id="apidoc.module.follow">module follow</a></h1>


    <h2>
        <a href="#apidoc.element.follow.follow" id="apidoc.element.follow.follow">
        function <span class="apidocSignatureSpan"></span>follow
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function follow_feed(opts, cb) {
  var ch_feed = new feed.Feed(opts);
  ch_feed.on('error' , function(er) { return cb &amp;&amp; cb.call(ch_feed, er) });
  ch_feed.on('change', function(ch) { return cb &amp;&amp; cb.call(ch_feed, null, ch) });

  // Give the caller a chance to hook into any events.
  process.nextTick(function() {
    ch_feed.follow();
  })

  return ch_feed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

process.on('uncaughtException', function(er) {
  puts('========= UNCAUGHT EXCEPTION; This is bad');
  puts(er.stack);
  setTimeout(function() { process.exit(1) }, 100);
})

feed.<span class="apidocCodeKeywordSpan">follow</span>();
}

exports.main = main;
if(!require.isBrowser &amp;&amp; process.argv[1] == module.filename)
main();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes" id="apidoc.element.follow.Changes">
        function <span class="apidocSignatureSpan">follow.</span>Changes
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Changes(opts) {
  var self = this
  stream.call(self)

  self.readable = true
  self.writable = true

  self.headers = {}
  self.statusCode = null

  opts = opts || {}
  self.feed = opts.feed || null // "continuous" or "longpoll"
  self.encoding = opts.encoding || 'utf8'

  self.log = opts.log
  if(!self.log) {
    self.log = lib.log4js.getLogger('change_stream')
    self.log.setLevel(DEFS.log_level)
  }

  self.is_sending = true
  self.is_ending = false
  self.is_dead = false

  self.source = null
  self.expect = null
  self.buf = null
  self.changes = []

  self.on('pipe', function(src) {
    if(!self.source)
      self.source = src
    else {
      var er = new Error('Already have a pipe source')
      er.source = self.source
      self.error(er)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed" id="apidoc.element.follow.Feed">
        function <span class="apidocSignatureSpan">follow.</span>Feed
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Feed(opts) {
  var self = this;
  EventEmitter.call(self);

  opts = opts || {}

  self.feed = 'continuous';
  self.heartbeat         = opts.heartbeat || DEFAULT_HEARTBEAT;
  self.max_retry_seconds = opts.max_retry_seconds || DEFAULT_MAX_RETRY_SECONDS;
  self.inactivity_ms = null;
  self.initial_retry_delay = opts.initial_retry_delay || INITIAL_RETRY_DELAY;
  self.response_grace_time = opts.response_grace_time || RESPONSE_GRACE_TIME;

  self.headers = {};
  self.request = opts.request || {} // Extra options for potentially future versions of request. The caller can supply them.

  self.since = 0;
  self.is_paused = false
  self.caught_up = false
  self.retry_delay = self.initial_retry_delay;

  self.query_params = {}; // Extra `req.query` values for filter functions

  if(typeof opts === 'string')
    opts = {'db': opts};

  Object.keys(opts).forEach(function(key) {
    if (typeof self[key] !== 'function')
      self[key] = opts[key];
  })

  self.pending = { request     : null
                 , activity_at : null
                 };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
process.stdout.write(str + "\n");
}

function main() {
var db = require.isBrowser ? (process.env.db || '/_users') : process.argv[2];
puts('Watching: ' + db);

var feed = new couch_changes.<span class="apidocCodeKeywordSpan">Feed</span>();
feed.db = db;
feed.since = (process.env.since === 'now') ? 'now' : parseInt(process.env.since || '0');

feed.heartbeat = (process.env.heartbeat || '3000').replace(/s$/, '000');
feed.heartbeat = parseInt(feed.heartbeat);

if(require.isBrowser)
...</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes" id="apidoc.module.follow.Changes">module follow.Changes</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.Changes" id="apidoc.element.follow.Changes.Changes">
        function <span class="apidocSignatureSpan">follow.</span>Changes
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Changes(opts) {
  var self = this
  stream.call(self)

  self.readable = true
  self.writable = true

  self.headers = {}
  self.statusCode = null

  opts = opts || {}
  self.feed = opts.feed || null // "continuous" or "longpoll"
  self.encoding = opts.encoding || 'utf8'

  self.log = opts.log
  if(!self.log) {
    self.log = lib.log4js.getLogger('change_stream')
    self.log.setLevel(DEFS.log_level)
  }

  self.is_sending = true
  self.is_ending = false
  self.is_dead = false

  self.source = null
  self.expect = null
  self.buf = null
  self.changes = []

  self.on('pipe', function(src) {
    if(!self.source)
      self.source = src
    else {
      var er = new Error('Already have a pipe source')
      er.source = self.source
      self.error(er)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.super_" id="apidoc.element.follow.Changes.super_">
        function <span class="apidocSignatureSpan">follow.Changes.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Changes.prototype" id="apidoc.module.follow.Changes.prototype">module follow.Changes.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.destroy" id="apidoc.element.follow.Changes.prototype.destroy">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  var self = this
  self.log.debug('destroy')

  self.is_dead = true
  self.is_ending = false
  self.is_sending = false

  if(self.source &amp;&amp; typeof self.source.abort == 'function')
    return self.source.abort()

  if(self.source &amp;&amp; typeof self.source.destroy === 'function')
    self.source.destroy()

  // Often the source is from the request package, so destroy its response object.
  if(self.source &amp;&amp; self.source.__isRequestRequest &amp;&amp; self.source.response
  &amp;&amp; typeof self.source.response.destroy === 'function')
    self.source.response.destroy()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

function destroy_req(req) {
if(req)
  destroy_response(req.response)

if(req &amp;&amp; typeof req.destroy == 'function')
  req.<span class="apidocCodeKeywordSpan">destroy</span>()
}

function destroy_response(response) {
if(!response)
  return;

if(typeof response.abort === 'function')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.destroySoon" id="apidoc.element.follow.Changes.prototype.destroySoon">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>destroySoon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroySoon = function () {
  var self = this
  throw new Error('not implemented')
  //return self.request.destroySoon()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self.source.response.destroy()
}


Changes.prototype.destroySoon = function() {
  var self = this
  throw new Error('not implemented')
  //return self.request.<span class="apidocCodeKeywordSpan">destroySoon</span>()
}

//
// Internal implementation
//

Changes.prototype.normalize_data = function(data, encoding) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.emit_changes" id="apidoc.element.follow.Changes.prototype.emit_changes">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>emit_changes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit_changes = function () {
  var self = this

  while(self.is_sending &amp;&amp; self.changes.length &gt; 0) {
    var change = self.changes.shift()
    if(change === "") {
      self.log.debug('emit: heartbeat')
      self.emit('heartbeat')
    }

    else {
      self.log.debug('emit: data')
      self.emit('data', change)
    }
  }

  if(self.is_sending &amp;&amp; self.is_ending &amp;&amp; self.changes.length === 0) {
    self.is_ending = false
    self.readable = false
    self.log.debug('emit: end')
    self.emit('end')
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


Changes.prototype.resume = function() {
  var self = this
  self.is_sending = true
  if(self.source &amp;&amp; self.source.resume)
    self.source.resume()
  self.<span class="apidocCodeKeywordSpan">emit_changes</span>()
}

//
// Writable stream API
//

Changes.prototype.write = function(data, encoding) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.end" id="apidoc.element.follow.Changes.prototype.end">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>end
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (data, encoding) {
  var self = this

  self.is_ending = true
  self.writable = false

  // Always call write, even with no data, so it can fire the "end" event.
  self.write(data, encoding)

  if(self.feed === 'longpoll') {
    var changes = [ DEFS.longpoll_header ].concat(self.buf).join('')
    try { changes = JSON.parse(changes) || {} }
    catch (er) { return self.error(er) }

    if(!Array.isArray(changes.results))
      return self.error(new Error('No "results" field in feed'))
    if(self.changes.length !== 0)
      return self.error(new Error('Changes are already queued: ' + JSON.stringify(self.changes)))

    self.changes = changes.results.map(function(change) { return JSON.stringify(change) })
    return self.emit_changes()
  }

  else if(self.feed === 'continuous') {
    if(self.buf !== "")
      self.log.debug('Unprocessed data after "end" called: ' + util.inspect(self.buf))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.error" id="apidoc.element.follow.Changes.prototype.error">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>error
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (er) {
  var self = this

  self.readable = false
  self.writable = false
  self.emit('error', er)

  // The write() method sometimes returns this value, so if there was an error, make write() return false.
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})

feed.on('response', function() {
  puts('Streaming response:');
})

feed.on('error', function(er) {
  //console.<span class="apidocCodeKeywordSpan">error</span>(er);
  console.error('Changes error ============\n' + er.stack);
  setTimeout(function() { process.exit(0) }, 100);
})

process.on('uncaughtException', function(er) {
  puts('========= UNCAUGHT EXCEPTION; This is bad');
  puts(er.stack);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.normalize_data" id="apidoc.element.follow.Changes.prototype.normalize_data">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>normalize_data
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalize_data = function (data, encoding) {
  var self = this

  if(data instanceof Buffer)
    data = data.toString(encoding)
  else if(typeof data === 'undefined' &amp;&amp; typeof encoding === 'undefined')
    data = ""

  if(typeof data != 'string')
    return self.error(new Error('Not a string or Buffer: ' + util.inspect(data)))

  if(self.feed !== 'continuous' &amp;&amp; self.feed !== 'longpoll')
    return self.error(new Error('Must set .feed to "continuous" or "longpoll" before writing data'))

  if(self.expect === null)
    self.expect = (self.feed == 'longpoll')
                    ? DEFS.longpoll_header
                    : ""

  var prefix = data.substr(0, self.expect.length)
  data = data.substr(prefix.length)

  var expected_part = self.expect.substr(0, prefix.length)
    , expected_remainder = self.expect.substr(expected_part.length)

  if(prefix !== expected_part)
    return self.error(new Error('Prefix not expected '+util.inspect(expected_part)+': ' + util.inspect(prefix)))

  self.expect = expected_remainder
  return data
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// Writable stream API
//

Changes.prototype.write = function(data, encoding) {
var self = this

data = self.<span class="apidocCodeKeywordSpan">normalize_data</span>(data, encoding)
if(typeof data != 'string')
  return // Looks like normalize_data emitted an error.

if(self.feed === 'longpoll')
  return self.write_longpoll(data)
else if(self.feed === 'continuous')
  return self.write_continuous(data)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.pause" id="apidoc.element.follow.Changes.prototype.pause">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  var self = this
  self.is_sending = false

  if(self.source &amp;&amp; self.source.pause)
    self.source.pause()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var now = new Date;
self.pending.request = changes_stream;
self.pending.activity_at = now;
self.pending.wait_timer  = null;

// Just re-run the pause or resume to do the needful on changes_stream (self.pending.request).
if(self.is_paused)
  self.<span class="apidocCodeKeywordSpan">pause</span>()
else
  self.resume()

// The inactivity timer is for time between *changes*, or time between the
// initial connection and the first change. Therefore it goes here.
self.change_at = now;
if(self.inactivity_ms) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.resume" id="apidoc.element.follow.Changes.prototype.resume">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  var self = this
  self.is_sending = true
  if(self.source &amp;&amp; self.source.resume)
    self.source.resume()
  self.emit_changes()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
d.configure(i);return d.require(a,c)};d.config=function(a){return d(a)};typeof require==="undefined"&amp;&amp;(require
=d);d.toUrl=function(a){return z._.toUrl(a)};d.version="0.26.0";d.isArray=E;d.isFunction=M;d.mixin=V;d.jsExtRegExp=/^\/|:|\?|\.js$/;i=d.s={contexts:z,skipAsync:{},isPageLoaded:!B,readyCalls:[]};if(d.isAsync=d.isBrowser=B)if(u=i.head=document.getElementsByTagName("head")[0],L=document.getElementsByTagName("base")[0])u=i.head=L.parentNode;d.onError=function(a){throw a;};d.load=function(a,c,
g){var e=a.loaded;e[c]||(e[c]=!1);a.scriptCount+=1;d.attach(g,a,c);if(a.jQuery&amp;&amp;!a.jQueryIncremented)W(a.jQuery,!0),a.
jQueryIncremented=!0};define=d.def=function(a,c,g){var e,i;typeof a!=="string"&amp;&amp;(g=c,c=a,a=null);d.isArray(c
)||(g=c,c=[]);!a&amp;&amp;!c.length&amp;&amp;d.isFunction(g)&amp;&amp;g.length&amp;&amp;(g.toString().replace(ma,"&amp;#
x22;).replace(na,function(a,d){c.push(d)}),c=(g.length===1?["require"]:["require","exports","
module"]).concat(c));if(N&amp;&amp;(e=I||la()))a||(a=e.getAttribute("data-requiremodule")),i=z[e.getAttribute(&amp;#
x22;data-requirecontext")];
(i?i.defQueue:U).push([a,c,g])};define.amd={multiversion:!0,plugins:!0,jQuery:!0};d.exec=function(a){return eval(a)};d.execCb=function
(a,c,d,e){return c.apply(e,d)};d.onScriptLoad=function(a){var c=a.currentTarget||a.srcElement,g;if(a.type==="load"||oa
.test(c.readyState))C=null,a=c.getAttribute("data-requirecontext"),g=c.getAttribute("data-requiremodule"),z[
a].completeLoad(g),c.detachEvent&amp;&amp;!da?c.detachEvent("onreadystatechange",d.onScriptLoad):c.removeEventListener
("load",d.onScriptLoad,!1)};d.attach=
function(a,c,g,e,q){var j;if(B)return e=e||d.onScriptLoad,j=c&amp;&amp;c.config&amp;&amp;c.config.xhtml?document.createElementNS
("http://www.w3.org/1999/xhtml","html:script"):document.createElement("script"),j.type=q||"text
/javascript",j.charset="utf-8",j.async=!i.skipAsync[a],c&amp;&amp;j.setAttribute("data-requirecontext"
;,c.contextName),j.setAttribute("data-requiremodule",g),j.attachEvent&amp;&amp;!da?(N=!0,j.attachEvent("onreadystatechange
",e)):j.addEventListener("load",e,!1),j.src=a,I=j,L?u.insertBefore(j,L):u.appendChild(j),
I=null,j;else if(ca)e=c.loaded,e[g]=!1,importScripts(a),c.completeLoad(g);return null};if(B){v=document.getElementsByTagName("
;script");for(H=v.length-1;H&gt;-1&amp;&amp;(A=v[H]);H--){if(!u)u=A.parentNode;if(D=A.getAttribute("data-main"
;)){if(!q.baseUrl)v=D.split("/"),A=v.pop(),v=v.length?v.join("/")+"/":"./",q.baseUrl=v,D
=A.replace(ba,"");q.deps=q.deps?q.deps.concat(D):[D];break}}}i.baseUrl=q.baseUrl;d.pageLoaded=function(){if(!i.isPageLoaded
){i.isPageLoaded=!0;Q&amp;&amp;clearInterval(Q);if(ea)document.readyState="complete";
d.callReady()}};d.checkReadyState=function(){var a=i.contexts,c;for(c in a)if(!(c in J)&amp;&amp;a[c].waitCount)return;i.isDone
=!0;d.callReady()};d.callReady=function(){var a=i.readyCalls,c,d,e;if(i.isPageLoaded&amp;&amp;i.isDone){if(a.length){i.readyCalls
=[];for(c=0;d=a[c];c++)d()}a=i.contexts;for(e in a)if(!(e in J)&amp;&amp;(c=a[e],c.jQueryIncremented))W(c.jQuery,!1),c.jQueryIncremented
=!1}};d.ready=function(a){i.isPageLoaded&amp;&amp;i.isDone?a():i.readyCalls.push(a);return d};if(B){if(document.addEventListener
){if(document.addEventListener("DOMContentLoaded",
d.pageLoaded,!1),window.addEventListener("load",d.pageLoaded,!1),!document.readyState)ea=!0,document.readyState="
loading"}else window.attachEvent&amp;&amp;(window.attachEvent("onload",d.pageLoaded),self===self.top&amp;&amp;
;(Q=setInterval(function(){try{document.body&amp;&amp;(document.documentElement.doScroll("left"),d.pageLoaded())}catch
(a){}},30)));document.readyState==="complete"&amp;&amp;d.pageLoaded()}d(q);if(d.isAsync&amp;&amp;typeof setTimeout
!=="undefined")w=i.contexts[q.context||"_"],w.requireWait=!0,setTimeout(function(){w.requireWait=
!1;w.takeGlobalQueue();w.jQueryCheck();w.scriptCount||w.<span class="apidocCodeKeywordSpan">resume</span>();d.checkReadyState()},
0)}})();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.setEncoding" id="apidoc.element.follow.Changes.prototype.setEncoding">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setEncoding
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEncoding = function (encoding) {
  var self = this
  self.encoding = encoding // TODO
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.setHeader" id="apidoc.element.follow.Changes.prototype.setHeader">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>setHeader
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setHeader = function (key, val) {
  var self = this
  self.headers[key] = val
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.write" id="apidoc.element.follow.Changes.prototype.write">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (data, encoding) {
  var self = this

  data = self.normalize_data(data, encoding)
  if(typeof data != 'string')
    return // Looks like normalize_data emitted an error.

  if(self.feed === 'longpoll')
    return self.write_longpoll(data)
  else if(self.feed === 'continuous')
    return self.write_continuous(data)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//    limitations under the License.

var lib = require('./lib')
, couch_changes = require('./api')
;

function puts(str) {
process.stdout.<span class="apidocCodeKeywordSpan">write</span>(str + "\n");
}

function main() {
var db = require.isBrowser ? (process.env.db || '/_users') : process.argv[2];
puts('Watching: ' + db);

var feed = new couch_changes.Feed();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.write_continuous" id="apidoc.element.follow.Changes.prototype.write_continuous">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_continuous
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write_continuous = function (data) {
  var self = this

  var offset, json, change
    , buf = (self.buf || "") + data

  self.log.debug('write: ' + util.inspect({'data':data, 'buf':buf}))

  // Buf could have 0, 1, or many JSON objects in it.
  while((offset = buf.indexOf("\n")) &gt;= 0) {
    json = buf.substr(0, offset);
    buf = buf.substr(offset + 1);
    self.log.debug('JSON: ' + util.inspect(json))

    // Heartbeats (empty strings) are fine, but otherwise confirm valid JSON.
    if(json === "")
      ;

    else if(json[0] !== '{')
      return self.error(new Error('Non-object JSON data: ' + json))

    else {
      try { change = JSON.parse(json) }
      catch (er) { return self.error(er) }

      self.log.debug('Object: ' + util.inspect(change))
      json = JSON.stringify(change)
    }

    // Change (or heartbeat) looks good.
    self.changes.push(json)
  }

  // Remember the unused data and send all known good changes (or heartbeats). The data (or heartbeat)
  // event listeners may call .pause() so remember the is_sending state now before calling them.
  var was_sending = self.is_sending
  self.buf = buf
  self.emit_changes()
  return was_sending
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
data = self.normalize_data(data, encoding)
if(typeof data != 'string')
  return // Looks like normalize_data emitted an error.

if(self.feed === 'longpoll')
  return self.write_longpoll(data)
else if(self.feed === 'continuous')
  return self.<span class="apidocCodeKeywordSpan">write_continuous</span>(data)
}


Changes.prototype.write_longpoll = function(data) {
var self = this

if(self.buf === null)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Changes.prototype.write_longpoll" id="apidoc.element.follow.Changes.prototype.write_longpoll">
        function <span class="apidocSignatureSpan">follow.Changes.prototype.</span>write_longpoll
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write_longpoll = function (data) {
  var self = this

  if(self.buf === null)
    self.buf = []

  self.buf.push(data)
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var self = this

data = self.normalize_data(data, encoding)
if(typeof data != 'string')
  return // Looks like normalize_data emitted an error.

if(self.feed === 'longpoll')
  return self.<span class="apidocCodeKeywordSpan">write_longpoll</span>(data)
else if(self.feed === 'continuous')
  return self.write_continuous(data)
}


Changes.prototype.write_longpoll = function(data) {
var self = this
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed" id="apidoc.module.follow.Feed">module follow.Feed</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.Feed" id="apidoc.element.follow.Feed.Feed">
        function <span class="apidocSignatureSpan">follow.</span>Feed
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Feed(opts) {
  var self = this;
  EventEmitter.call(self);

  opts = opts || {}

  self.feed = 'continuous';
  self.heartbeat         = opts.heartbeat || DEFAULT_HEARTBEAT;
  self.max_retry_seconds = opts.max_retry_seconds || DEFAULT_MAX_RETRY_SECONDS;
  self.inactivity_ms = null;
  self.initial_retry_delay = opts.initial_retry_delay || INITIAL_RETRY_DELAY;
  self.response_grace_time = opts.response_grace_time || RESPONSE_GRACE_TIME;

  self.headers = {};
  self.request = opts.request || {} // Extra options for potentially future versions of request. The caller can supply them.

  self.since = 0;
  self.is_paused = false
  self.caught_up = false
  self.retry_delay = self.initial_retry_delay;

  self.query_params = {}; // Extra `req.query` values for filter functions

  if(typeof opts === 'string')
    opts = {'db': opts};

  Object.keys(opts).forEach(function(key) {
    if (typeof self[key] !== 'function')
      self[key] = opts[key];
  })

  self.pending = { request     : null
                 , activity_at : null
                 };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
process.stdout.write(str + "\n");
}

function main() {
var db = require.isBrowser ? (process.env.db || '/_users') : process.argv[2];
puts('Watching: ' + db);

var feed = new couch_changes.<span class="apidocCodeKeywordSpan">Feed</span>();
feed.db = db;
feed.since = (process.env.since === 'now') ? 'now' : parseInt(process.env.since || '0');

feed.heartbeat = (process.env.heartbeat || '3000').replace(/s$/, '000');
feed.heartbeat = parseInt(feed.heartbeat);

if(require.isBrowser)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.super_" id="apidoc.element.follow.Feed.super_">
        function <span class="apidocSignatureSpan">follow.Feed.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.Feed.prototype" id="apidoc.module.follow.Feed.prototype">module follow.Feed.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.check_for_catchup" id="apidoc.element.follow.Feed.prototype.check_for_catchup">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>check_for_catchup
        <span class="apidocSignatureSpan">(seq)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function check_for_catchup(seq) {
  var self = this

  if (self.is_db_updates)
    return
  if(self.caught_up)
    return
  if(seq &lt; self.original_db_seq)
    return

  self.caught_up = true
  self.emit('catchup', seq)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(result) {
  self.log.debug('Builtin filter PASS for change: ' + change.seq);
  return self.on_good_change(change);
} else {
  self.log.debug('Builtin filter FAIL for change: ' + change.seq);

  // Even with a filtered change, a "catchup" event might still be appropriate.
  self.<span class="apidocCodeKeywordSpan">check_for_catchup</span>(change.seq)
}
}

Feed.prototype.on_good_change = function on_good_change(change) {
var self = this;

if(self.inactivity_ms &amp;&amp; !self.inactivity_timer)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.confirm" id="apidoc.element.follow.Feed.prototype.confirm">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>confirm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function confirm_feed() {
  var self = this;

  self.db_safe = lib.scrub_creds(self.db);

  var endpoint = self.is_db_updates ? 'server' : 'database';

  self.log.debug('Checking ' + endpoint + ': ' + self.db_safe);

  var confirm_timeout = self.heartbeat * 3; // Give it time to look up the name, connect, etc.
  var timeout_id = setTimeout(function() {
    return self.die(new Error('Timeout confirming ' + endpoint + ': ' + self.db_safe));
  }, confirm_timeout);

  var headers = lib.JP(lib.JS(self.headers));
  headers.accept = 'application/json';

  var uri = self.is_db_updates ? self.db.replace(/\/_db_updates$/, '') : self.db;
  var req = {'uri':uri, 'headers':headers}
  Object.keys(self.request).forEach(function(key) {
    req[key] = self.request[key];
  })

  req = request(req, db_response)
  self.emit('confirm_request', req)

  function db_response(er, resp, body) {
    clearTimeout(timeout_id);

    if(er)
      return self.die(er);

    var db;
    try {
      db = JSON.parse(body)
    } catch(json_er) {
      return self.emit('error', json_er)
    }

    if(!self.is_db_updates &amp;&amp; !self.dead &amp;&amp; (!db.db_name || !db.instance_start_time))
      return self.emit('error', new Error('Bad DB response: ' + body));

    if(self.is_db_updates &amp;&amp; !self.dead &amp;&amp; !db.couchdb)
      return self.emit('error', new Error('Bad server response: ' + body));

    if (!self.is_db_updates)
      self.original_db_seq = db.update_seq

    self.log.debug('Confirmed ' + endpoint + ': ' + self.db_safe);
    self.emit('confirm', db);

    if(self.since == 'now') {
      self.log.debug('Query since "now" is the same as query since -1')
      self.since = -1
    }

    if(self.since == -1) {
      self.log.debug('Query since '+self.since+' will start at ' + db.update_seq)
      self.since = db.update_seq
    } else if(self.since &lt; 0) {
      if(isNaN(db.update_seq))
        return self.emit('error', new Error('DB requires specific id in "since"'));

      self.log.debug('Query since '+self.since+' will start at ' + (db.update_seq + self.since + 1))
      self.since = db.update_seq + self.since + 1
    }

    // If the next change would come after the current update_seq, just fake a catchup event now.
    if(self.original_db_seq == self.since) {
      self.caught_up = true
      self.emit('catchup', db.update_seq)
    }

    return self.query();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(typeof self.heartbeat !== 'number')
  throw new Error('Required "heartbeat" value');

self.log = lib.log4js.getLogger(self.db);
self.log.setLevel(process.env.follow_log_level || "info");

self.emit('start');
return self.<span class="apidocCodeKeywordSpan">confirm</span>();
}

Feed.prototype.confirm = function confirm_feed() {
var self = this;

self.db_safe = lib.scrub_creds(self.db);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.die" id="apidoc.element.follow.Feed.prototype.die">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>die
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">die = function (er) {
  var self = this;

  if(er)
    self.log.fatal('Fatal error: ' + er.stack);

  // Warn code executing later that death has occured.
  self.dead = true

  clearTimeout(self.retry_timer)
  clearTimeout(self.inactivity_timer)
  clearTimeout(self.pending.wait_timer)

  self.inactivity_timer = null
  self.pending.wait_timer = null

  var req = self.pending.request;
  self.pending.request = null;
  if(req) {
    self.log.debug('Destroying req ' + req.id());
    destroy_req(req);
  }

  if(er)
    self.emit('error', er);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var endpoint = self.is_db_updates ? 'server' : 'database';

self.log.debug('Checking ' + endpoint + ': ' + self.db_safe);

var confirm_timeout = self.heartbeat * 3; // Give it time to look up the name, connect, etc.
var timeout_id = setTimeout(function() {
  return self.<span class="apidocCodeKeywordSpan">die</span>(new Error('Timeout confirming ' + endpoint + ': '
; + self.db_safe));
}, confirm_timeout);

var headers = lib.JP(lib.JS(self.headers));
headers.accept = 'application/json';

var uri = self.is_db_updates ? self.db.replace(/\/_db_updates$/, '') : self.db;
var req = {'uri':uri, 'headers':headers}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.follow" id="apidoc.element.follow.Feed.prototype.follow">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>follow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function follow_feed() {
  var self = this;

  self.db = self.db || self.url || self.uri
  delete self.url
  delete self.uri

  if(!self.db)
    throw new Error('Database URL required');

  if (self.db.match(/\/_db_updates$/))
    self.is_db_updates = true;

  if(self.is_db_updates)
    delete self.since;

  if(self.feed !== 'continuous' &amp;&amp; self.feed !== 'longpoll')
    throw new Error('The only valid feed options are "continuous" and "longpoll"');

  if(typeof self.heartbeat !== 'number')
    throw new Error('Required "heartbeat" value');

  self.log = lib.log4js.getLogger(self.db);
  self.log.setLevel(process.env.follow_log_level || "info");

  self.emit('start');
  return self.confirm();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

process.on('uncaughtException', function(er) {
  puts('========= UNCAUGHT EXCEPTION; This is bad');
  puts(er.stack);
  setTimeout(function() { process.exit(1) }, 100);
})

feed.<span class="apidocCodeKeywordSpan">follow</span>();
}

exports.main = main;
if(!require.isBrowser &amp;&amp; process.argv[1] == module.filename)
main();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.got_activity" id="apidoc.element.follow.Feed.prototype.got_activity">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>got_activity
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">got_activity = function () {
  var self = this

  if (self.dead)
    return

  //
  // We may not have a wait_timer so just clear it and null it out if it does
  // exist
  //
  clearTimeout(self.pending.wait_timer)
  self.pending.wait_timer = null
  self.pending.activity_at = new Date
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.log.warn('No pending request to resume')
}


Feed.prototype.on_couch_heartbeat = function on_couch_heartbeat() {
var self = this

self.<span class="apidocCodeKeywordSpan">got_activity</span>()
if(self.dead)
  return self.log.debug('Skip heartbeat processing for dead feed')

self.emit('heartbeat')

if(self.dead)
  return self.log.debug('No wait: heartbeat listener stopped this feed')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_change" id="apidoc.element.follow.Feed.prototype.on_change">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_change
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_change(change) {
  var self = this;

  if(!self.is_db_updates &amp;&amp; !change.seq)
    return self.die(new Error('No seq value in change: ' + lib.JS(change)));

  if(!self.is_db_updates &amp;&amp; change.seq == self.since) {
    self.log.debug('Bad seq value ' + change.seq + ' since=' + self.since);
    return destroy_req(self.pending.request);
  }

  if(typeof self.filter !== 'function')
    return self.on_good_change(change);

  var req = lib.JDUP({'query': self.pending.request.changes_query});
  var filter_args;

  if (self.is_db_updates) {
    if(!change.db_name || !change.type)
      return self.die(new Error('Internal _db_updates filter needs .db_name and .type in change ', change));
    filter_args = [change.db_name, change.type, req];
  } else {
    if(!change.doc)
      return self.die(new Error('Internal filter needs .doc in change ' + change.seq));

    // Don't let the filter mutate the real data.
    var doc = lib.JDUP(change.doc);
    filter_args = [doc, req];
  }
  var result = false;
  try {
    result = self.filter.apply(null, filter_args);
  } catch (er) {
    self.log.debug('Filter error', er);
  }

  result = (result &amp;&amp; true) || false;
  if(result) {
    self.log.debug('Builtin filter PASS for change: ' + change.seq);
    return self.on_good_change(change);
  } else {
    self.log.debug('Builtin filter FAIL for change: ' + change.seq);

    // Even with a filtered change, a "catchup" event might still be appropriate.
    self.check_for_catchup(change.seq)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  del_er.last_seq = change.last_seq
  return self.die(del_er)
}

if(!self.is_db_updates &amp;&amp; !change.seq)
  return self.die(new Error('Change has no .seq field: ' + JSON.stringify(change)))

self.<span class="apidocCodeKeywordSpan">on_change</span>(change)

// on_change() might work its way all the way to a "change" event, and the listener
// might call .stop(), which means among other things that no more events are desired.
// The die() code sets a self.dead flag to indicate this.
if(self.dead)
  return self.log.debug('No wait: change listener stopped this feed')
self.wait()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_data" id="apidoc.element.follow.Feed.prototype.on_couch_data">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_data
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_data(change) {
  var self = this;
  self.log.debug('Data from ' + self.pending.request.id());

  self.got_activity()
  if(self.dead)
    return self.log.debug('Skip data processing for dead feed')

  // The changes stream guarantees that this data is valid JSON.
  change = JSON.parse(change)

  //self.log.debug('Object:\n' + util.inspect(change));
  if(!self.is_db_updates &amp;&amp; 'last_seq' in change) {
    self.log.warn('Stopping upon receiving a final message: ' + JSON.stringify(change))
    var del_er = new Error('Database deleted after change: ' + change.last_seq)
    del_er.deleted = true
    del_er.last_seq = change.last_seq
    return self.die(del_er)
  }

  if(!self.is_db_updates &amp;&amp; !change.seq)
    return self.die(new Error('Change has no .seq field: ' + JSON.stringify(change)))

  self.on_change(change)

  // on_change() might work its way all the way to a "change" event, and the listener
  // might call .stop(), which means among other things that no more events are desired.
  // The die() code sets a self.dead flag to indicate this.
  if(self.dead)
    return self.log.debug('No wait: change listener stopped this feed')
  self.wait()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_end" id="apidoc.element.follow.Feed.prototype.on_couch_end">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_end() {
  var self = this;

  self.log.debug('Changes feed ended ' + self.pending.request.id());
  self.pending.request = null;
  return self.retry();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_error" id="apidoc.element.follow.Feed.prototype.on_couch_error">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_error
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_error(er) {
  var self = this;

  self.log.debug('Changes query eror: ' + lib.JS(er.stack));
  return self.retry();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_couch_heartbeat" id="apidoc.element.follow.Feed.prototype.on_couch_heartbeat">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_couch_heartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_couch_heartbeat() {
  var self = this

  self.got_activity()
  if(self.dead)
    return self.log.debug('Skip heartbeat processing for dead feed')

  self.emit('heartbeat')

  if(self.dead)
    return self.log.debug('No wait: heartbeat listener stopped this feed')
  self.wait()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_good_change" id="apidoc.element.follow.Feed.prototype.on_good_change">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_good_change
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_good_change(change) {
  var self = this;

  if(self.inactivity_ms &amp;&amp; !self.inactivity_timer)
    return self.die(new Error('Cannot find inactivity timer during change'));

  clearTimeout(self.inactivity_timer);
  self.inactivity_timer = null;
  if(self.inactivity_ms)
    self.inactivity_timer = setTimeout(function() { self.on_inactivity() }, self.inactivity_ms);

  self.change_at = new Date;

  if(!self.is_db_updates)
    self.since = change.seq;

  self.emit('change', change);

  self.check_for_catchup(change.seq)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if(!self.is_db_updates &amp;&amp; change.seq == self.since) {
  self.log.debug('Bad seq value ' + change.seq + ' since=' + self.since);
  return destroy_req(self.pending.request);
}

if(typeof self.filter !== 'function')
  return self.<span class="apidocCodeKeywordSpan">on_good_change</span>(change);

var req = lib.JDUP({'query': self.pending.request.changes_query});
var filter_args;

if (self.is_db_updates) {
  if(!change.db_name || !change.type)
    return self.die(new Error('Internal _db_updates filter needs .db_name and .type in change ', change));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_inactivity" id="apidoc.element.follow.Feed.prototype.on_inactivity">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_inactivity
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_inactivity() {
  var self = this;
  var now = new Date;
  var elapsed_ms = now - self.change_at;
  var elapsed_s  = elapsed_ms / 1000;

  //
  // Since this is actually not fatal, lets just totally reset and start a new
  // request, JUST in case something was bad.
  //
  self.log.debug('Req ' + self.pending.request.id() + ' made no changes for ' + elapsed_s + 's');
  return self.restart();

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.resume()

// The inactivity timer is for time between *changes*, or time between the
// initial connection and the first change. Therefore it goes here.
self.change_at = now;
if(self.inactivity_ms) {
  clearTimeout(self.inactivity_timer);
  self.inactivity_timer = setTimeout(function() { self.<span class="apidocCodeKeywordSpan">on_inactivity</span>() }, self.inactivity_ms
);
}

changes_stream.on('heartbeat', handler_for('heartbeat'))
changes_stream.on('error', handler_for('error'))
changes_stream.on('data', handler_for('data'))
changes_stream.on('end', handler_for('end'))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.on_timeout" id="apidoc.element.follow.Feed.prototype.on_timeout">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>on_timeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on_timeout() {
  var self = this;
  if (self.dead)
    return self.log.debug('No timeout: change listener stopped this feed');

  self.log.debug('Timeout')

  var now = new Date;
  var elapsed_ms = now - self.pending.activity_at;

  self.emit('timeout', {elapsed_ms:elapsed_ms, heartbeat:self.heartbeat, id:self.pending.request.id()});

<span class="apidocCodeCommentSpan">  /*
  var msg = ' for timeout after ' + elapsed_ms + 'ms; heartbeat=' + self.heartbeat;
  if(!self.pending.request.id)
    self.log.warn('Closing req (no id) ' + msg + ' req=' + util.inspect(self.pending.request));
  else
    self.log.warn('Closing req ' + self.pending.request.id() + msg);
  */
</span>
  destroy_req(self.pending.request);
  self.retry()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var req_id = self.pending.request &amp;&amp; self.pending.request.id()
var msg = 'Req ' + req_id + ' timeout=' + timeout_ms;
if(self.inactivity_ms)
  msg += ', inactivity=' + self.inactivity_ms;
msg += ': ' + self.db_safe;

self.log.debug(msg);
self.pending.wait_timer = setTimeout(function() { self.<span class="apidocCodeKeywordSpan">on_timeout</span>() }, timeout_ms);
}

Feed.prototype.got_activity = function() {
var self = this

if (self.dead)
  return
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.pause" id="apidoc.element.follow.Feed.prototype.pause">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  var self = this
    , was_paused = self.is_paused

  // Emit pause after pausing the stream, to allow listeners to react.
  self.is_paused = true
  if(self.pending &amp;&amp; self.pending.request &amp;&amp; self.pending.request.pause)
    self.pending.request.pause()
  else
    self.log.warn('No pending request to pause')

  if(!was_paused)
    self.emit('pause')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var now = new Date;
self.pending.request = changes_stream;
self.pending.activity_at = now;
self.pending.wait_timer  = null;

// Just re-run the pause or resume to do the needful on changes_stream (self.pending.request).
if(self.is_paused)
  self.<span class="apidocCodeKeywordSpan">pause</span>()
else
  self.resume()

// The inactivity timer is for time between *changes*, or time between the
// initial connection and the first change. Therefore it goes here.
self.change_at = now;
if(self.inactivity_ms) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.prep" id="apidoc.element.follow.Feed.prototype.prep">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>prep
        <span class="apidocSignatureSpan">(changes_stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prep_request(changes_stream) {
  var self = this;

  var now = new Date;
  self.pending.request = changes_stream;
  self.pending.activity_at = now;
  self.pending.wait_timer  = null;

  // Just re-run the pause or resume to do the needful on changes_stream (self.pending.request).
  if(self.is_paused)
    self.pause()
  else
    self.resume()

  // The inactivity timer is for time between *changes*, or time between the
  // initial connection and the first change. Therefore it goes here.
  self.change_at = now;
  if(self.inactivity_ms) {
    clearTimeout(self.inactivity_timer);
    self.inactivity_timer = setTimeout(function() { self.on_inactivity() }, self.inactivity_ms);
  }

  changes_stream.on('heartbeat', handler_for('heartbeat'))
  changes_stream.on('error', handler_for('error'))
  changes_stream.on('data', handler_for('data'))
  changes_stream.on('end', handler_for('end'))

  return self.wait();

  function handler_for(ev) {
    var name = 'on_couch_' + ev;
    var inner_handler = self[name];

    return handle_confirmed_req_event;
    function handle_confirmed_req_event() {
      if(self.pending.request === changes_stream)
        return inner_handler.apply(self, arguments);

      if(!changes_stream.created_at)
        return self.die(new Error("Received data from unknown request")); // Pretty sure this is impossible.

      var s_to_now = (new Date() - changes_stream.created_at) / 1000;
      var s_to_req = '[no req]';
      if(self.pending.request)
        s_to_req = (self.pending.request.created_at - changes_stream.created_at) / 1000;

      var msg = ': ' + changes_stream.id() + ' to_req=' + s_to_req + 's, to_now=' + s_to_now + 's';

      if(ev == 'end' || ev == 'data' || ev == 'heartbeat') {
        self.log.debug('Old "' + ev + '": ' + changes_stream.id())
        return destroy_req(changes_stream)
      }

      self.log.warn('Old "'+ev+'"' + msg);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  changes_stream.log = lib.log4js.getLogger('stream ' + self.db)
  changes_stream.log.setLevel(self.log.level.levelStr)
  changes_stream.feed = self.feed
  feed_request.pipe(changes_stream)

  changes_stream.created_at = now
  changes_stream.id = function() { return feed_id }
  return self.<span class="apidocCodeKeywordSpan">prep</span>(changes_stream)
}
}

Feed.prototype.prep = function prep_request(changes_stream) {
var self = this;

var now = new Date;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.query" id="apidoc.element.follow.Feed.prototype.query">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>query
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query_feed() {
  var self = this;

  var query_params = JSON.parse(JSON.stringify(self.query_params));

  FEED_PARAMETERS.forEach(function(key) {
    if(key in self)
      query_params[key] = self[key];
  })

  if(typeof query_params.filter !== 'string')
    delete query_params.filter;

  if(typeof self.filter === 'function' &amp;&amp; !query_params.include_docs) {
    self.log.debug('Enabling include_docs for client-side filter');
    query_params.include_docs = true;
  }

  // Limit the response size for longpoll.
  var poll_size = 100;
  if(query_params.feed == 'longpoll' &amp;&amp; (!query_params.limit || query_params.limit &gt; poll_size))
    query_params.limit = poll_size;

  var feed_url = self.db + (self.is_db_updates ? '' : '/_changes') + '?' + querystring.stringify(query_params);

  self.headers.accept = self.headers.accept || 'application/json';
  var req = { method : 'GET'
            , uri    : feed_url
            , headers: self.headers
            , encoding: 'utf-8'
            }

  req.changes_query = query_params;
  Object.keys(self.request).forEach(function(key) {
    req[key] = self.request[key];
  })

  var now = new Date
    , feed_ts = lib.JDUP(now)
    , feed_id = process.env.follow_debug ? feed_ts.match(/\.(\d\d\d)Z$/)[1] : feed_ts

  self.log.debug('Feed query ' + feed_id + ': ' + lib.scrub_creds(feed_url))
  var feed_request = request(req)

  feed_request.on('response', function(res) {
    self.log.debug('Remove feed from agent pool: ' + feed_id)
    feed_request.req.socket.emit('agentRemove')

    // Simulate the old onResponse option.
    on_feed_response(null, res, res.body)
  })

  feed_request.on('error', on_feed_response)

  // The response headers must arrive within one heartbeat.
  var response_timer = setTimeout(response_timed_out, self.heartbeat + self.response_grace_time)
    , timed_out = false

  return self.emit('query', feed_request)

  function response_timed_out() {
    self.log.debug('Feed response timed out: ' + feed_id)
    timed_out = true
    return self.retry()
  }

  function on_feed_response(er, resp, body) {
    clearTimeout(response_timer)

    if((resp !== undefined &amp;&amp; resp.body) || body)
      return self.die(new Error('Cannot handle a body in the feed response: ' + lib.JS(resp.body || body)))

    if(timed_out) {
      self.log.debug('Ignoring late response: ' + feed_id);
      return destroy_response(resp);
    }

    if(er) {
      self.log.debug('Request error ' + feed_id + ': ' + er.stack);
      destroy_response(resp);
      return self.retry();
    }

    if(resp.statusCode !== 200) {
      self.log.debug('Bad changes response ' + feed_id + ': ' + resp.statusCode);
      destroy_response(resp);
      return self.retry();
    }

    self.log.debug('Good response: ' + feed_id);
    self.retry_delay = self.initial_retry_delay;

    self.emit('response', resp);

    var changes_stream = new Changes
    changes_stream.log = lib.log4js.getLogger('stream ' + self.db)
    changes_stream.log.setLevel(self.log.level.levelStr)
    changes_stream.feed = self.feed
    feed_request.pipe(changes_stream)

    changes_stream.created_at = now
    changes_stream.id = function() { return feed_id }
    return self.prep(changes_stream)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // If the next change would come after the current update_seq, just fake a catchup event now.
  if(self.original_db_seq == self.since) {
    self.caught_up = true
    self.emit('catchup', db.update_seq)
  }

  return self.<span class="apidocCodeKeywordSpan">query</span>();
}
}

Feed.prototype.query = function query_feed() {
var self = this;

var query_params = JSON.parse(JSON.stringify(self.query_params));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.restart" id="apidoc.element.follow.Feed.prototype.restart">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>restart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function restart() {
  var self = this

  self.emit('restart')

  // Kill ourselves and then start up once again
  self.stop()
  self.dead = false
  self.start()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var elapsed_s  = elapsed_ms / 1000;

//
// Since this is actually not fatal, lets just totally reset and start a new
// request, JUST in case something was bad.
//
self.log.debug('Req ' + self.pending.request.id() + ' made no changes for ' + elapsed_s + 's');
return self.<span class="apidocCodeKeywordSpan">restart</span>();

}

Feed.prototype.restart = function restart() {
var self = this

self.emit('restart')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.resume" id="apidoc.element.follow.Feed.prototype.resume">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  var self = this
    , was_paused = self.is_paused

  // Emit resume before resuming the data feed, to allow listeners to prepare.
  self.is_paused = false
  if(was_paused)
    self.emit('resume')

  if(self.pending &amp;&amp; self.pending.request &amp;&amp; self.pending.request.resume)
    self.pending.request.resume()
  else
    self.log.warn('No pending request to resume')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
d.configure(i);return d.require(a,c)};d.config=function(a){return d(a)};typeof require==="undefined"&amp;&amp;(require
=d);d.toUrl=function(a){return z._.toUrl(a)};d.version="0.26.0";d.isArray=E;d.isFunction=M;d.mixin=V;d.jsExtRegExp=/^\/|:|\?|\.js$/;i=d.s={contexts:z,skipAsync:{},isPageLoaded:!B,readyCalls:[]};if(d.isAsync=d.isBrowser=B)if(u=i.head=document.getElementsByTagName("head")[0],L=document.getElementsByTagName("base")[0])u=i.head=L.parentNode;d.onError=function(a){throw a;};d.load=function(a,c,
g){var e=a.loaded;e[c]||(e[c]=!1);a.scriptCount+=1;d.attach(g,a,c);if(a.jQuery&amp;&amp;!a.jQueryIncremented)W(a.jQuery,!0),a.
jQueryIncremented=!0};define=d.def=function(a,c,g){var e,i;typeof a!=="string"&amp;&amp;(g=c,c=a,a=null);d.isArray(c
)||(g=c,c=[]);!a&amp;&amp;!c.length&amp;&amp;d.isFunction(g)&amp;&amp;g.length&amp;&amp;(g.toString().replace(ma,"&amp;#
x22;).replace(na,function(a,d){c.push(d)}),c=(g.length===1?["require"]:["require","exports","
module"]).concat(c));if(N&amp;&amp;(e=I||la()))a||(a=e.getAttribute("data-requiremodule")),i=z[e.getAttribute(&amp;#
x22;data-requirecontext")];
(i?i.defQueue:U).push([a,c,g])};define.amd={multiversion:!0,plugins:!0,jQuery:!0};d.exec=function(a){return eval(a)};d.execCb=function
(a,c,d,e){return c.apply(e,d)};d.onScriptLoad=function(a){var c=a.currentTarget||a.srcElement,g;if(a.type==="load"||oa
.test(c.readyState))C=null,a=c.getAttribute("data-requirecontext"),g=c.getAttribute("data-requiremodule"),z[
a].completeLoad(g),c.detachEvent&amp;&amp;!da?c.detachEvent("onreadystatechange",d.onScriptLoad):c.removeEventListener
("load",d.onScriptLoad,!1)};d.attach=
function(a,c,g,e,q){var j;if(B)return e=e||d.onScriptLoad,j=c&amp;&amp;c.config&amp;&amp;c.config.xhtml?document.createElementNS
("http://www.w3.org/1999/xhtml","html:script"):document.createElement("script"),j.type=q||"text
/javascript",j.charset="utf-8",j.async=!i.skipAsync[a],c&amp;&amp;j.setAttribute("data-requirecontext"
;,c.contextName),j.setAttribute("data-requiremodule",g),j.attachEvent&amp;&amp;!da?(N=!0,j.attachEvent("onreadystatechange
",e)):j.addEventListener("load",e,!1),j.src=a,I=j,L?u.insertBefore(j,L):u.appendChild(j),
I=null,j;else if(ca)e=c.loaded,e[g]=!1,importScripts(a),c.completeLoad(g);return null};if(B){v=document.getElementsByTagName("
;script");for(H=v.length-1;H&gt;-1&amp;&amp;(A=v[H]);H--){if(!u)u=A.parentNode;if(D=A.getAttribute("data-main"
;)){if(!q.baseUrl)v=D.split("/"),A=v.pop(),v=v.length?v.join("/")+"/":"./",q.baseUrl=v,D
=A.replace(ba,"");q.deps=q.deps?q.deps.concat(D):[D];break}}}i.baseUrl=q.baseUrl;d.pageLoaded=function(){if(!i.isPageLoaded
){i.isPageLoaded=!0;Q&amp;&amp;clearInterval(Q);if(ea)document.readyState="complete";
d.callReady()}};d.checkReadyState=function(){var a=i.contexts,c;for(c in a)if(!(c in J)&amp;&amp;a[c].waitCount)return;i.isDone
=!0;d.callReady()};d.callReady=function(){var a=i.readyCalls,c,d,e;if(i.isPageLoaded&amp;&amp;i.isDone){if(a.length){i.readyCalls
=[];for(c=0;d=a[c];c++)d()}a=i.contexts;for(e in a)if(!(e in J)&amp;&amp;(c=a[e],c.jQueryIncremented))W(c.jQuery,!1),c.jQueryIncremented
=!1}};d.ready=function(a){i.isPageLoaded&amp;&amp;i.isDone?a():i.readyCalls.push(a);return d};if(B){if(document.addEventListener
){if(document.addEventListener("DOMContentLoaded",
d.pageLoaded,!1),window.addEventListener("load",d.pageLoaded,!1),!document.readyState)ea=!0,document.readyState="
loading"}else window.attachEvent&amp;&amp;(window.attachEvent("onload",d.pageLoaded),self===self.top&amp;&amp;
;(Q=setInterval(function(){try{document.body&amp;&amp;(document.documentElement.doScroll("left"),d.pageLoaded())}catch
(a){}},30)));document.readyState==="complete"&amp;&amp;d.pageLoaded()}d(q);if(d.isAsync&amp;&amp;typeof setTimeout
!=="undefined")w=i.contexts[q.context||"_"],w.requireWait=!0,setTimeout(function(){w.requireWait=
!1;w.takeGlobalQueue();w.jQueryCheck();w.scriptCount||w.<span class="apidocCodeKeywordSpan">resume</span>();d.checkReadyState()},
0)}})();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.retry" id="apidoc.element.follow.Feed.prototype.retry">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>retry
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry() {
  var self = this;

  clearTimeout(self.pending.wait_timer);
  self.pending.wait_timer = null;

  self.log.debug('Retry since=' + self.since + ' after ' + self.retry_delay + 'ms ')
  self.emit('retry', {since:self.since, after:self.retry_delay, db:self.db_safe});

  self.retry_timer = setTimeout(function() { self.query() }, self.retry_delay);

  var max_retry_ms = self.max_retry_seconds * 1000;
  self.retry_delay *= 2;
  if(self.retry_delay &gt; max_retry_ms)
    self.retry_delay = max_retry_ms;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
, timed_out = false

  return self.emit('query', feed_request)

  function response_timed_out() {
self.log.debug('Feed response timed out: ' + feed_id)
timed_out = true
return self.<span class="apidocCodeKeywordSpan">retry</span>()
  }

  function on_feed_response(er, resp, body) {
clearTimeout(response_timer)

if((resp !== undefined &amp;&amp; resp.body) || body)
  return self.die(new Error('Cannot handle a body in the feed response: ' + lib.JS(resp.body || body)))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.start" id="apidoc.element.follow.Feed.prototype.start">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function follow_feed() {
  var self = this;

  self.db = self.db || self.url || self.uri
  delete self.url
  delete self.uri

  if(!self.db)
    throw new Error('Database URL required');

  if (self.db.match(/\/_db_updates$/))
    self.is_db_updates = true;

  if(self.is_db_updates)
    delete self.since;

  if(self.feed !== 'continuous' &amp;&amp; self.feed !== 'longpoll')
    throw new Error('The only valid feed options are "continuous" and "longpoll"');

  if(typeof self.heartbeat !== 'number')
    throw new Error('Required "heartbeat" value');

  self.log = lib.log4js.getLogger(self.db);
  self.log.setLevel(process.env.follow_log_level || "info");

  self.emit('start');
  return self.confirm();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var self = this

  self.emit('restart')

  // Kill ourselves and then start up once again
  self.stop()
  self.dead = false
  self.<span class="apidocCodeKeywordSpan">start</span>()
}

module.exports = { "Feed" : Feed
                 };


/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.stop" id="apidoc.element.follow.Feed.prototype.stop">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>stop
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (val) {
  var self = this
  self.log.debug('Stop')

  // Die with no errors.
  self.die()
  self.emit('stop', val);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if(!self.is_db_updates &amp;&amp; !change.seq)
    return self.die(new Error('Change has no .seq field: ' + JSON.stringify(change)))

  self.on_change(change)

  // on_change() might work its way all the way to a "change" event, and the listener
  // might call .<span class="apidocCodeKeywordSpan">stop</span>(), which means among other things that no more events are desired
.
  // The die() code sets a self.dead flag to indicate this.
  if(self.dead)
    return self.log.debug('No wait: change listener stopped this feed')
  self.wait()
}

Feed.prototype.on_timeout = function on_timeout() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.Feed.prototype.wait" id="apidoc.element.follow.Feed.prototype.wait">
        function <span class="apidocSignatureSpan">follow.Feed.prototype.</span>wait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wait_for_event() {
  var self = this;
  self.emit('wait');

  if(self.pending.wait_timer)
    return self.die(new Error('wait() called but there is already a wait_timer: ' + self.pending.wait_timer));

  var timeout_ms = self.heartbeat * HEARTBEAT_TIMEOUT_COEFFICIENT;
  var req_id = self.pending.request &amp;&amp; self.pending.request.id()
  var msg = 'Req ' + req_id + ' timeout=' + timeout_ms;
  if(self.inactivity_ms)
    msg += ', inactivity=' + self.inactivity_ms;
  msg += ': ' + self.db_safe;

  self.log.debug(msg);
  self.pending.wait_timer = setTimeout(function() { self.on_timeout() }, timeout_ms);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  changes_stream.on('heartbeat', handler_for('heartbeat'))
  changes_stream.on('error', handler_for('error'))
  changes_stream.on('data', handler_for('data'))
  changes_stream.on('end', handler_for('end'))

  return self.<span class="apidocCodeKeywordSpan">wait</span>();

  function handler_for(ev) {
var name = 'on_couch_' + ev;
var inner_handler = self[name];

return handle_confirmed_req_event;
function handle_confirmed_req_event() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.cli" id="apidoc.module.follow.cli">module follow.cli</a></h1>


    <h2>
        <a href="#apidoc.element.follow.cli.main" id="apidoc.element.follow.cli.main">
        function <span class="apidocSignatureSpan">follow.cli.</span>main
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function main() {
  var db = require.isBrowser ? (process.env.db || '/_users') : process.argv[2];
  puts('Watching: ' + db);

  var feed = new couch_changes.Feed();
  feed.db = db;
  feed.since = (process.env.since === 'now') ? 'now' : parseInt(process.env.since || '0');

  feed.heartbeat = (process.env.heartbeat || '3000').replace(/s$/, '000');
  feed.heartbeat = parseInt(feed.heartbeat);

  if(require.isBrowser)
    feed.feed = 'longpoll';
  if(process.env.host)
    feed.headers.host = process.env.host;
  if(process.env.inactivity)
    feed.inactivity_ms = parseInt(process.env.inactivity);
  if(process.env.limit)
    feed.limit = parseInt(process.env.limit);

  feed.query_params.pid = process.pid;
  feed.filter = process.env.filter || example_filter;
  function example_filter(doc, req) {
    // This is a local filter. It runs on the client side.
    var label = 'Filter ' + (req.query.pid || '::');

    if(process.env.show_doc)
      console.log(label + ' doc: ' + JSON.stringify(doc));
    if(process.env.show_req)
      console.log(label + ' for ' + doc._id + ' req: ' + JSON.stringify(req));
    return true;
  }

  feed.on('confirm', function() {
    puts('Database confirmed: ' + db);
  })

  feed.on('change', function(change) {
    puts('Change:' + JSON.stringify(change));
  })

  feed.on('timeout', function(state) {
    var seconds = state.elapsed_ms / 1000;
    var hb = state.heartbeat / 1000;
    puts('Timeout after ' + seconds + 's inactive, heartbeat=' + hb + 's');
  })

  feed.on('retry', function(state) {
    if(require.isBrowser)
      puts('Long polling since ' + state.since);
    else
      puts('Retry since ' + state.since + ' after ' + state.after + 'ms');
  })

  feed.on('response', function() {
    puts('Streaming response:');
  })

  feed.on('error', function(er) {
    //console.error(er);
    console.error('Changes error ============\n' + er.stack);
    setTimeout(function() { process.exit(0) }, 100);
  })

  process.on('uncaughtException', function(er) {
    puts('========= UNCAUGHT EXCEPTION; This is bad');
    puts(er.stack);
    setTimeout(function() { process.exit(1) }, 100);
  })

  feed.follow();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.eventemitter2" id="apidoc.module.follow.eventemitter2">module follow.eventemitter2</a></h1>


    <h2>
        <a href="#apidoc.element.follow.eventemitter2.EventEmitter2" id="apidoc.element.follow.eventemitter2.EventEmitter2">
        function <span class="apidocSignatureSpan">follow.eventemitter2.</span>EventEmitter2
        <span class="apidocSignatureSpan">(conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter(conf) {
  this._events = new Object;
  configure.call(this, conf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.feed" id="apidoc.module.follow.feed">module follow.feed</a></h1>


    <h2>
        <a href="#apidoc.element.follow.feed.Feed" id="apidoc.element.follow.feed.Feed">
        function <span class="apidocSignatureSpan">follow.feed.</span>Feed
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Feed(opts) {
  var self = this;
  EventEmitter.call(self);

  opts = opts || {}

  self.feed = 'continuous';
  self.heartbeat         = opts.heartbeat || DEFAULT_HEARTBEAT;
  self.max_retry_seconds = opts.max_retry_seconds || DEFAULT_MAX_RETRY_SECONDS;
  self.inactivity_ms = null;
  self.initial_retry_delay = opts.initial_retry_delay || INITIAL_RETRY_DELAY;
  self.response_grace_time = opts.response_grace_time || RESPONSE_GRACE_TIME;

  self.headers = {};
  self.request = opts.request || {} // Extra options for potentially future versions of request. The caller can supply them.

  self.since = 0;
  self.is_paused = false
  self.caught_up = false
  self.retry_delay = self.initial_retry_delay;

  self.query_params = {}; // Extra `req.query` values for filter functions

  if(typeof opts === 'string')
    opts = {'db': opts};

  Object.keys(opts).forEach(function(key) {
    if (typeof self[key] !== 'function')
      self[key] = opts[key];
  })

  self.pending = { request     : null
                 , activity_at : null
                 };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
process.stdout.write(str + "\n");
}

function main() {
var db = require.isBrowser ? (process.env.db || '/_users') : process.argv[2];
puts('Watching: ' + db);

var feed = new couch_changes.<span class="apidocCodeKeywordSpan">Feed</span>();
feed.db = db;
feed.since = (process.env.since === 'now') ? 'now' : parseInt(process.env.since || '0');

feed.heartbeat = (process.env.heartbeat || '3000').replace(/s$/, '000');
feed.heartbeat = parseInt(feed.heartbeat);

if(require.isBrowser)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.index" id="apidoc.module.follow.index">module follow.index</a></h1>


    <h2>
        <a href="#apidoc.element.follow.index.JDUP" id="apidoc.element.follow.index.JDUP">
        function <span class="apidocSignatureSpan">follow.index.</span>JDUP
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JDUP = function (obj) { return JSON.parse(JSON.stringify(obj)) }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

req.changes_query = query_params;
Object.keys(self.request).forEach(function(key) {
  req[key] = self.request[key];
})

var now = new Date
  , feed_ts = lib.<span class="apidocCodeKeywordSpan">JDUP</span>(now)
  , feed_id = process.env.follow_debug ? feed_ts.match(/\.(\d\d\d)Z$/)[1] : feed_ts

self.log.debug('Feed query ' + feed_id + ': ' + lib.scrub_creds(feed_url))
var feed_request = request(req)

feed_request.on('response', function(res) {
  self.log.debug('Remove feed from agent pool: ' + feed_id)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.index.JP" id="apidoc.element.follow.index.JP">
        function <span class="apidocSignatureSpan">follow.index.</span>JP
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.log.debug('Checking ' + endpoint + ': ' + self.db_safe);

var confirm_timeout = self.heartbeat * 3; // Give it time to look up the name, connect, etc.
var timeout_id = setTimeout(function() {
  return self.die(new Error('Timeout confirming ' + endpoint + ': ' + self.db_safe));
}, confirm_timeout);

var headers = lib.<span class="apidocCodeKeywordSpan">JP</span>(lib.JS(self.headers));
headers.accept = 'application/json';

var uri = self.is_db_updates ? self.db.replace(/\/_db_updates$/, '') : self.db;
var req = {'uri':uri, 'headers':headers}
Object.keys(self.request).forEach(function(key) {
  req[key] = self.request[key];
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.index.JS" id="apidoc.element.follow.index.JS">
        function <span class="apidocSignatureSpan">follow.index.</span>JS
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stringify() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.log.debug('Checking ' + endpoint + ': ' + self.db_safe);

var confirm_timeout = self.heartbeat * 3; // Give it time to look up the name, connect, etc.
var timeout_id = setTimeout(function() {
  return self.die(new Error('Timeout confirming ' + endpoint + ': ' + self.db_safe));
}, confirm_timeout);

var headers = lib.JP(lib.<span class="apidocCodeKeywordSpan">JS</span>(self.headers));
headers.accept = 'application/json';

var uri = self.is_db_updates ? self.db.replace(/\/_db_updates$/, '') : self.db;
var req = {'uri':uri, 'headers':headers}
Object.keys(self.request).forEach(function(key) {
  req[key] = self.request[key];
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.index.clearTimeout" id="apidoc.element.follow.index.clearTimeout">
        function <span class="apidocSignatureSpan">follow.index.</span>clearTimeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearTimeout = function () { return timeouts.clearTimeout.apply(this, arguments) }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.index.scrub_creds" id="apidoc.element.follow.index.scrub_creds">
        function <span class="apidocSignatureSpan">follow.index.</span>scrub_creds
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scrub_creds(url) {
  return url.replace(/^(https?:\/\/)[^:]+:[^@]+@(.*)$/, '$1$2'); // Scrub username and password
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.emit('start');
return self.confirm();
}

Feed.prototype.confirm = function confirm_feed() {
var self = this;

self.db_safe = lib.<span class="apidocCodeKeywordSpan">scrub_creds</span>(self.db);

var endpoint = self.is_db_updates ? 'server' : 'database';

self.log.debug('Checking ' + endpoint + ': ' + self.db_safe);

var confirm_timeout = self.heartbeat * 3; // Give it time to look up the name, connect, etc.
var timeout_id = setTimeout(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.index.setTimeout" id="apidoc.element.follow.index.setTimeout">
        function <span class="apidocSignatureSpan">follow.index.</span>setTimeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTimeout = function () { return timeouts.setTimeout.apply(this, arguments) }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.follow.index.timeouts" id="apidoc.element.follow.index.timeouts">
        function <span class="apidocSignatureSpan">follow.index.</span>timeouts
        <span class="apidocSignatureSpan">(set, clear)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeouts = function (set, clear) {
  timeouts.setTimeout = set
  timeouts.clearTimeout = clear
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.follow.stream" id="apidoc.module.follow.stream">module follow.stream</a></h1>


    <h2>
        <a href="#apidoc.element.follow.stream.Changes" id="apidoc.element.follow.stream.Changes">
        function <span class="apidocSignatureSpan">follow.stream.</span>Changes
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Changes(opts) {
  var self = this
  stream.call(self)

  self.readable = true
  self.writable = true

  self.headers = {}
  self.statusCode = null

  opts = opts || {}
  self.feed = opts.feed || null // "continuous" or "longpoll"
  self.encoding = opts.encoding || 'utf8'

  self.log = opts.log
  if(!self.log) {
    self.log = lib.log4js.getLogger('change_stream')
    self.log.setLevel(DEFS.log_level)
  }

  self.is_sending = true
  self.is_ending = false
  self.is_dead = false

  self.source = null
  self.expect = null
  self.buf = null
  self.changes = []

  self.on('pipe', function(src) {
    if(!self.source)
      self.source = src
    else {
      var er = new Error('Already have a pipe source')
      er.source = self.source
      self.error(er)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>